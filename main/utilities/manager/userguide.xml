
<!-- chapter user-guide -->
<chapter>
   <title>NSCLDAQ Manager subsystem (new in 12.0)</title>
   <para>
    As the FRIB begins operating, security concerns are moving the laboratory
    away from employing a single experiment account from which an experiment is
    run.  Instead, with the NSCLDAQ manager subystem, the persistent software
    in an experiment can be run by a single account but controlled by
    users logged in to
    accounts.
   </para>
   <para>
    This chapter provides a description of this facility and how to use it.
    The chapter references man pages and reference information where appropriate.
   </para>
   <para>
    The sections in the chapter are organized as follows:
   </para>
   <itemizedlist>
    <listitem>
       <para>
        <link linkend='sec.mgr.intro' endterm='sec.mgr.intro.title' />
        Provides introductory information that's useful for understanding the
        remainder of the presentation.
       </para>
    </listitem>
    <listitem>
       <para>
          <link linkend='sec.mgr.config' endterm='sec.mgr.config.title' />
          Describes the objects the DAQ manager controls and how to configure
          them.
       </para>
    </listitem>
    <listitem>
       <para>
          <link linkend='sec.mgr.running' endterm='sec.mgr.running.title' />
          Describes how to run the manager and how to run an experiment using
          the manager.
       </para>
    </listitem>
    <listitem>
       <para>
          <link linkend='sec.mgr.readout' endterm='sec.mgr.readout.title' />
          Describes what you need to do to prepare your NSCLDAQ Readout programs
          to run under control of the manager.  Reference material describes
          the REST protocol non NSCLDAQ Readout programs must implement to
          participate in experiments run by the manager.
       </para>
    </listitem>
    <listitem>
       <para>
          <link linkend='sec.mgr.eventbuilder' endterm='sec.mgr.eventbuilder.title' />
          Describes how to use the NSCLDAQ event builder with the manager.
       </para>
    </listitem>
   </itemizedlist>
  <section id='sec.mgr.intro'>
      <title id='sec.mgr.intro.title'>Introduction</title>
      <para>
        The NSCLDAQ experiment manager, or <firstterm>manager</firstterm> as
        we'll call it in the remainder of this document, is a persistent server
        that can manage the persistent software in an experiment.  Below,
        the term <firstterm>advertised</firstterm>, in the context of network
        services means that these services are registered with the
        NSCLDAQ port manager.
      </para>
      <para>
        The manager uses a configuration database, stored in an SQLite3 database
        file to drive its actions.  It provides an advertised REST interface
        that allows local or remote clients to interact with it at run time.
        It also provides an advertised port which allows clients to monitor
        the output and error streams of programs run by the manager.
      </para>
      <para>
        The use of ports advertised with the port manager allows the manager
        to be identified by clients by supplying the host in which the manager
        is running and the user that started it.
      </para>
      <para>
        In an experiment that uses the manager, the life cycle of its use looks
        a bit like this:
      </para>
      <itemizedlist>
        <listitem>
           <para>
              Create and populate a configuration database that describes the
              entities the manager will control.  Several GUI based tools are
              provided to support this process, and a well defined API exists
              to support the creation of additional tools.
           </para>
        </listitem>
        <listitem>
           <para>
               As the experiment begins, select a system in which the manager
               is run and start it up.  The only information you have to pass
               to the manager is the location of its configuration database.
               The manager will run for the
               duration of the experiment.  Command line tools support starting
               the experiment and shutting it down.
           </para>
        </listitem>
        <listitem>
           <para>
              Use GUI clients to interact with the manager during the run.
              Typically these clients will include ouput monitors, and run
              control panels, as well as optional event builder statistics monitors
           </para>
           <para>
            The clients are written to allow more than one instance of each
            control panel to run at any time allowing the experiment to be
            controlled from e.g. within the vaults for setup and testing and
            out in the counting areas when running with beam.
           </para>
        </listitem>
      </itemizedlist>
      <para>
        Note that the manager has been written to understand singularity containers
        and to start them as needed to run persistent software within containers.
        More about that in
        <link linkend='sec.mgr.config' endterm='sec.mgr.config.title' />.
      </para>
   </section>
  <section id='sec.mgr.config'>
     <title id='sec.mgr.config.title'>Managed Objects and Configuration</title>
     <para>
      This section describes the objects the manager understands and the
      tools available to configure the manager.
     </para>
     <para>
      The remainder of this section describes:
     </para>
     <itemizedlist>
      <listitem>
         <para>
            How to create an initial, empty configuration database file. 
         </para>
      </listitem>
      <listitem>
         <para>
            Singularity container definitions and how to add them to the
            configuration database.
         </para>
      </listitem>
      <listitem>
         <para>
            Program definitions and how to add and edit them in the configuration
            database.
         </para>
      </listitem>
      <listitem>
         <para>
            Sequences, how to add them and specify their triggers as well as
            how to configure the steps in a sequence.
         </para>
      </listitem>
      <listitem>
         <para>
            Event loggers, the types of event loggers supported and how to
            add them to the experiment configuration.
         </para>
      </listitem>
      <listitem>
         <para>
            The key value store and how to add/modify values to it. 
         </para>
      </listitem>
      <listitem>
         <para>
            User and roles and how to configure them.
         </para>
      </listitem>
     </itemizedlist>
     <section>
        <title>Creating a New Configuration Database.</title>
        <para>
          The manager relies on an SQLite3 database file for its configuration.
          SQLite3 database files contain, in addition to data, schema definitions
          that describe the structure of the database and relationships between
          database tables.  Furthermore, Some tables are populated with an initial
          set of values.
        </para>
        <para>
          The
          <link linkend='daq1.mg_mkconfig' endterm='daq1.mg_mkconfig.title' />
          command creates manager configuration database files with the correct
          schema and an initial set of data.  
        </para>
        <para>
          The <command>mk_config</command> command can be run on an existing
          database.  It will not ovewrite existing data.   In the event future
          manager configuration databases use a different schema, this program
          will also support converting an existing database to one acceptable
          to the newer NSCLDAQ version.
        </para>
     </section>
     <section>
        <title>Singularity Containers and the Manager</title>
        <para>
          At the FRIB there are conflicts between wanting to keep systems up to
          date while maintaining a stable environment on which the DAQ system
          can run.   We're helped by the fact that we have kept kernel mode
          code to a bare minimum.  This makes NSCLDAQ, for the most part,
          dependent only on the user mode libraries and utilities.
        </para>
        <para>
          Singularity containers provide a convenient technology that encapsulates
          the user mode run-time of a version of Linux in a single file (a
          container image) and the ability to swap out the chunks of the native
          file system that contain user mode libraries and utilities with the
          environment captured by the container image.
        </para>
        <para>
          The DAQ manager can launch applications either in a native environment
          or in a containerized environment chosen by the user.  In practice,
          the NSCLDAQ team has provided suitable container images and has also
          made these container images and associated <filename>/usr/opt</filename>
          directory tree tarballs available at <ulink url='https://sf.net' />
          in the nscldaq project.
        </para>
        <para>
          Note that regardless of whether or not the application is launched
          native or containerized, an SSH Pipe is used to launch the application.
          You must therefore set up your <filename>~/.ssh/authorized_keys</filename>
          file to allow SSH to connect to the hosts you are running programs in
          without the need to specify a passowrd interactively.  At the
          FRIB, all DAQ systems share common home directory trees so this  is
          fairly simple.  The process well documented on the web if you search
          for e.g. <literal>ssh without password</literal>.  Since the
          web is volatile we will not provide specific links here.
        </para>
        <para>
          The <command>$DAQBIN/mg_cfgcontainers</command> utility allows you to
          define and name containers and the bindings they have with the
          native filesystem.  You can also launch this program by double clicking
          <literal>Containers</literal> from the list of configuration utilities
          displayed by <command>$DAQBIN/mg_config</command>.  Both of these
          programs require a single argument, the path of the configuration database
          file.
          For reference information about these programs see:
          <link linkend='daq1.mg_cfgcontainers' endterm='daq1.mg_cfgcontainers.title' />
          and
          <link linkend='daq1.mg_config' endterm='daq1.mg_config.title' />.
        </para>
        <para>
            The top level window of this program is a list of container names on the
            left side and a list of filesystem bindings on the right. Clicking
            a container name populates the bindings list box with the bindings
            for the seleted container.  
          </para>
          <para>
            Clicking the <guibutton>Init Script..</guibutton> button displays the
            initialization script for the container.  The initialization script is
            a script that is run prior to running every program in the container.
            It allows you to perform common environment setup operations (e.g.
            sourcing the correct <filename>daqconfig.bash</filename> file).
            The <emphasis>contents</emphasis> of the configuration file are
            stored in the database so that the initialization script is stable
            under edits to the original file.
          </para>
          <para>
            The <guibutton>New...</guibutton> and <guibutton>Edit...</guibutton>
            bring up a dialog that allows you to define a container.  The
            only difference between the two buttons is that <guibutton>Edit...</guibutton>
            pre-populates the dialog with the definition of the selected container.
            You can use this dialog to set the container image file, add/remove
            bindings, set the container name, and pull in the contents of
            an initialization script.
          </para>
          <para>
             When the <guibutton>Ok</guibutton> button is clicked, the definition
             is saved.  If <guibutton>Cancel</guibutton> is clicked, the
             definition is discarded.  
          </para>
          <para>
            When the dialog is brought up with
             <guibutton>Edit...</guibutton> <guibutton>Cancel</guibutton> retains
             the old definition.  Furthermore if <guibutton>Ok</guibutton> is clicked
             but you change the name of the container, a new container defintion
             is created using that name.  This allows you to create a new
             container definition beginning with the definition of an existing
             container as a starting point.
          </para>
          <para>
            When the dialog is brought up with the <guibutton>New...</guibutton>,
            <guibutton>Cancel</guibutton> makes no changes to the database,
            <guibutton>Ok</guibutton> saves the new container definition.
            Take care not to duplicate the name of an existing container.
          </para>
          <para>
            Note that the <guibutton>Ok</guibutton> button directly modifies
            the database.  This is why there is no <guibutton>Save</guibutton>
            button on the main window.
          </para>
     </section>
     <section>
        <title>Program Definitions</title>
        <para>
          Programs are the entities that make up the bulk of the persistent
          part of an NSCLDAQ experiment.  Programs can be run <firstterm>bare</firstterm>
          or <firstterm>containerized</firstterm>.   A program consists of
          the following elements:
        </para>
        <variablelist>
          <varlistentry>
             <term>Name</term>
             <listitem>
                 <para>
                  A unique name that identifies the program.  This name is referred
                  to when inserting the program into the steps of a sequence
                  (don't worry too much about what that means until you've
                  read about sequences).
               </para>
            </listitem>
          </varlistentry>
          <varlistentry>
             <term>Program File</term>
             <listitem>
                 <para>
                  This is the thing that's actually run.  Note that if the
                  program is run containerized, this file path must be expressed
                  in the filesystem seen from within the container, not the
                  host filesystem.  Furthermore, a consequence of this is that
                  only files visible within the container can successfully launch.
               </para>
            </listitem>
          </varlistentry>
          <varlistentry>
             <term>Host</term>
             <listitem>
                 <para>
                  The name of a system in which the program will be run.
               </para>
            </listitem>
          </varlistentry>
          <varlistentry>
             <term>Container</term>
             <listitem>
                 <para>
                  If non-empty, this is the name of a container in which the
                  program will be run.  The manager will take care of launching
                  that container in the required host when the program is run,
                  and then arrange for the program to be run inside that containerized
                  environment.
               </para>
            </listitem>
          </varlistentry>
          <varlistentry>
             <term>Working Directory</term>
             <listitem>
                 <para>
                  The working directory in which the program runs. Once more,
                  if the program is containerized, this must be expressed in terms
                  of the filesystem as it's seen within the container.
               </para>
            </listitem>
          </varlistentry>
          <varlistentry>
             <term>Type</term>
             <listitem>
                 <para>
                  There are three program types:
                  <literal>Transitory</literal> programs are launched, and
                  are expected to exit, having performed their task.  An example
                  of a transitory program might be programs that set the run number
                  for a Readout program as part of a sequence that's triggered
                  on a <literal>BEGIN</literal> transition.
                  
               </para>
              <para>
                  <literal>Persistent</literal> programs are programs that are
                  intended to run continuously but won't make data taking fail
                  if they exit.  For example, while a persistent SpecTcl is not
                  expected to fail, an error in the user specific code may cause
                  it to fail.  However halting data taking is not required if
                  that happens.
              </para>
              <para>
                <literal>Critical</literal> programs are persistent programs that
                are essential
                to data taking.  For example a Readout program.  If a critical
                program exits, the manager forces the system to <literal>SHUTDOWN</literal>
                until corrective action can be taken.
              </para>
            </listitem>
          </varlistentry>
          <varlistentry>
             <term>Options</term>
             <listitem>
                 <para>
                  These are  program options that are supplied to the program
                  on the command line.  These normally have values (but are
                  not required to have them).  For example an NSCLDAQ Readout
                  program may require the <option>--ring</option> option to specify
                  the name of the ringbuffer into which it will put its data.
               </para>
              <para>
                Any number of program options can be specified.
              </para>
            </listitem>
          </varlistentry>
          <varlistentry>
             <term>Parameters</term>
             <listitem>
                 <para>
                  These are just command line parameters.  For example, the
                  program that can feed a Readout the run number needs to know
                  the host and user running the manager and the name of the Readout
                  program.  These are fed as command line parameters.
               </para>
            </listitem>
          </varlistentry>
          <varlistentry>
             <term>Environment</term>
             <listitem>
                 <para>
                  These are environment variables the program may require.
                  Note that for containerized programs, consider definiting these
                   in the container's initialization file if they are common
                   across many programs.
               </para>
            </listitem>
          </varlistentry>
        </variablelist>
        <para>
          The <command>mg_cfgprogram</command> utility allows you to create new
          program definitions and edit existing ones.  There is no support for
          deleting a program definitions, but unused program definitions are
          harmless.
          Reference information about <command>mg_cfgprogram</command> is
          available at
          <link linkend='daq1.mg_cfgprogram' endterm='daq1.mg_cfgprogram.title' />
        </para>
        <para>
            The main window of this editor is a table listing the programs that are
            currently defined.  The program name, program file, host and container
            of all defined programs are shown in this table.  If the Container
            column is empty for a program it is run natively in the specified host.
            Note, as you might expect, for containerized applications, the
            program file is the path to the program as it appears in the container
            file system.  Not the host filesystem.
          </para>
          <para>
            CLicking the <guibutton>New..</guibutton> button or double clicking
            on a program in the table, brings up an editor window.  The only
            difference between the two methods to bring up this window are that
            double clicking a program will load that program into the editor
            window.
          </para>
          <para>
            For the most part the editor window is straightforward, the Name
            of the program must be a unique name.  The program file
            <guibutton>Browse...</guibutton> button allows you to browse for
            the program file.  This browses in the filesystem in effect at the
            time the editor is being run.  If, for example, you are running the
            editor natively but the program will be containerized,
            you may need to modify the final path selected by hand to match
            what the container sees.  The Container <guibutton>Browse...</guibutton>
            buttons allows you to select from the list of defined containers in
            which the program can run.
          </para>
          <para>
            A <literal>Type</literal> radio button group allows you to specify
            the program type.
          </para>
          <para>
            The <literal>Program Options</literal> listbox shows the options
            that are defined for the program.  To add a new option,
            enter the option namme (e.g. <literal>--ring</literal>) and
            option value (e.g. <literal>fox</literal>) in the Name and Value
            entry text boxes and click the <guibutton>New</guibutton> button.
            To remove an option  click it in the list, this also supports
            editing the option as the name/value pair are loaded into the
            corresponding entries where they can be edited and recreated.
            This bit of mechanics is the same for all of the editor elements
            described below.
          </para>
          <para>
            Similarly, the <literal>Program Parameters</literal> listbox
            shows parameters that are passed to the program.  You can think of
            parameters as options with no value.  However, the program parameters
            are passed to the program <emphasis>after</emphasis> the program's
            options.   Create a new parameter by entering its value and clicking
            the <guibutton>New</guibutton> button below it.  Delete or edit
            by clicking it in the list.  Note that often parameters are positional
            and you must take care of that when editing.
          </para>
          <para>
            The <literal>Program Environment</literal> define environment
            variables that will be defined when the program executes.
            Editing these is identical to editing <literal>Program Options:</literal>
          </para>
          <para>
            Clicking <guibutton>OK</guibutton> saves the definition in the database
            and refreshes the list of programs in the main window.
            Clicking <guibutton>Cancel</guibutton> closes the editor window
            without making any changes
          </para>
          
     </section>
     <section>
        <title>State Machine, Sequences, Sequence Triggers, and Steps</title>
        <para>
          The NSCLDAQ manager implements a state machine.  That is the manager is
          always in a well defined state or transitioning to another state that
          is reachable in the <firstterm>state diagram</firstterm> defined in its
          configuration databases.    A default state diagram is initially loaded
          into the configuration database when it is created and, while it can
          be edited it's normally a reasonable state diagram for NSCLDAQ.
        </para>
        <para>
          The configuration data base can specify that <firstterm>sequences</firstterm>
          are associated with state transitions.  A sequence is an ordered list
          of programs that are run to perform the tasks needed by the
          transition. Sequences run one at a time, in the order they were
          defined.  We'll describe the tool for editing sequences later in this
          section.
        </para>
        <para>
          A sequence consists of steps.  Each step specifies a program (defined
           in the configuration database), and optional pre and post delays.
           Steps are started in the order specified in the sequence definition.
           If a step runs a transient program, the sequence will wait until that
           program exits before performing the next step.  This allows ordering
           to be ensured for sequential operations.
        </para>
        <para>
          Although normally you do not need to modify the states and allowed
          transitions loaded into the manager, the program
          <command>mg_stateedit</command>
          (Reference pages in
          <link linkend='daq1.mg_stateedit' endterm='daq1.mg_stateedit.title' />)
          provides the ability to define an arbitrary state machine.
          In this implementation, however, there are a few constraints you must
          observe when modifying the states and their allowed transitions:
        </para>
        <orderedlist>
          <listitem>
             <para>
                A <literal>SHUTDOWN</literal>  state must be defined.  It will
                be the initial system state.
             </para>
          </listitem>
          <listitem>
             <para>
                To support failure actions, all states you define must be allowed
                to transition to the <literal>SHUTDOWN</literal> state.
             </para>
          </listitem>
          <listitem>
             <para>
                If you intend to use the Run control control panel, you must
                define a state named <literal>BEGIN</literal> and it must
                represent a state where data taking is active.  You must also
                define a state named <literal>END</literal> and it must represent
                a state in which the system is up and running but data taking
                is not active.  You also <emphasis>should</emphasis> define a state
                named <literal>HWINIT</literal> and that should represent a state
                in which any one time initialization of the data taking hardware
                has completed.
             </para>
          </listitem>
        </orderedlist>
        <para>
            Before describing the <command>mg_stateedit</command> user
            interface; some terminology.  The states
            the state machine can transition to from any givnen state
            are called <firstterm>Successor States</firstterm>.  The states
            from which a state can transition to are called
            <firstterm>Precursor States</firstterm>.
            The process of defining a state machine is that of defining the
            states and, for each state defining its successor states.  In some
            cases, it's also convenient to define a state's precursor states.
            The <command>mg_stateedit</command> command allows for both.
          </para>
          <para>
            The window resented by <command>mg_stateedit</command> is primarily
            composed of three list boxes.  The center list box lists the defined
            states selecting (single clicking) a state in the States list box
            populates the left listbox with that state's precursor states and
            the right list box with that state's successor states.
          </para>
          <para>
            Below each list box is a <guibutton>-</guibutton> button. Clicking that
            button when a state is selected in any list box removes that state
            from that listbox:
          </para>
          <itemizedlist>
            <listitem>
               <para>
                  Clicking that button below the middle listbox removes that state's
                  definitions (cleaning up all transitions to that state from
                  precursor states and all transitions to successor states as well).
               </para>
            </listitem>
            <listitem>
               <para>
                  Clicking that button below the left listbox removes that state
                  from the precursor states of the selected state in the middle
                  listbox. This removes the allowed transition from the precursor
                  state to the selected state.
               </para>
            </listitem>
            <listitem>
               <para>
                  Similarly, clicking that button below the right list box removes
                  that state from the successor states of the selected state in
                  the middle listbox.  This removes the allowed transition from
                  the selected state to that successor state.
               </para>
            </listitem>
          </itemizedlist>
          <para>
            Below the <guibutton>-</guibutton> buttons below each listbox are
            text entry widgets and a <guibutton>+</guibutton> button.
          </para>
          <itemizedlist>
            <listitem>
               <para>
                  To add a new state, type a unique state name  in the middle
                  entry and click its <guibutton>+</guibutton> button.
               </para>
            </listitem>
            <listitem>
               <para>
                  To add a new precursor state  to the selected state,
                  type the name of an existing state in the left listbox and
                  click its <guibutton>+</guibutton> button.  The state
                  must be defined or an error will be displayed.
               </para>
            </listitem>
            <listitem>
               <para>
                  To add a new successor state to the selected state,
                  type the name of an existing state in the right listbox
                  and click its <guibutton>+</guibutton> button.  Once more the
                  state must already be defined or an error will be displayed.
               </para>
            </listitem>
          </itemizedlist>
          <para>
            Note that all changes change the underlying database immediately.
          </para>
          <para>
            The state transitions of the manager trigger the execution of
            sequences that are associated with the successor state being
            transitioned to.  These sequences can be defined and edited using
            the sequence editor <command>mg_seqedit</command>.  Reference
            material for that program is located in
            <link linkend='daq1.mg_seqedit' endterm='daq1.mg_seqedit.title' />.
          </para>
          <para>
            Sequences are bound to or <firstterm>triggered by</firstterm> states.
            When a transition is performed into
            a state, the sequences triggered by those states are run.  The
            sequences are run one at a time in the order in which they were defined.
          </para>
          <para>
            The GUI for <command>mg_seqedit</command> consists of a listbox
            that displays the sequences that have been defined.  An entry and
            drop down list provide the ability to define new sequences.
            
          </para>
          <para>
            To create a new sequence, ype in a new unique sequence name in the
            text entry box, and select its trigger state
            from the drop down. Clicking <guibutton>Add</guibutton> adds the
            new sequence to the list of defined sequences.
          </para>
          <para>
            Sequences are edited by double-clicking them in the listbox.  This
            is also how a new sequence is assigned steps.  Double clicking
            a sequence pops up the sequence step editor window.
          </para>
          <para>
            Each step has a step number, which determines its order in the sequence.
            The step numbers are floating point numbers ensuring new steps can
            always be inserted between existing steps. Steps also have a program
            that is run and optional delays before and after the step
          </para>
          <para>
            To add a new step, select the program from the pulldown menu
            near the bottom of the window, optionally set non zero pre and post
            delay values and click <guibutton>Add</guibutton>  by default
            new steps are added at the end.  If a step is selected (single click it),
            when a new step is added, the step is inserteed above that step.
          </para>
          <para>
            A context menu is brought up by right clicking any step.  The menu
            allows yout to delete the step, move it up in the order or move it
            down. 
          </para>
          <para>
            At the very bottom of the page are three action buttons:
          </para>
          <variablelist>
            <varlistentry>
               <term><guibutton>Save</guibutton></term>
               <listitem>
                   <para>
                    Saves the updated (or new) sequence steps.
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term><guibutton>Delete...</guibutton></term>
               <listitem>
                   <para>
                    Prompts for confirmation and then deletes the sequence
                    if you confirm.
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term><guibutton>Cancel</guibutton></term>
               <listitem>
                   <para>
                    Makes no changes.  The existing sequence is unmodified and
                    the new sequence is not saved.
                   </para>
                </listitem>
            </varlistentry>
          </variablelist>
     </section>
     <section>
        <title>Event Logging and the Manager</title>
        <para>
          Under the ReadoutGUI, experiments have a primary event logger and,
          by using the multilogger package, a set of simple loggers that
          just logged event data into a directory.  The primary logger
          Managed a directory tree that provided both run and experiment views
          of the data as well as the capability of associating arbitrary metadata
          with each run, in the form of a user selected set of files and
          directory sub-trees.
        </para>
        <para>
          At the heart of all of this was a common utility called
          <command>eventlog</command> which just writes event data from
          a ring to a file.  Event logging in the manager allows you to
          define an arbitrary set of <firstterm>complete</firstterm> and
          <firstterm>partial</firstterm> loggers.  The best way to think
          of these are that complete loggers maintain the same directory tree
          as the ReadoutGUI's primary event logger while partial loggers
          are like the loggers managed by the multilogger package.
        </para>
        <para>
          While you can create any number of either type  of event logger,
          it's important to consider the complete bandwidth requirements of doing
          so throughout the system.  While using several event loggers provide
          valuable offline debugging information during production running the
          best throughput is obtained by only using a single event logger.
          Thus the event log subsystem allows loggers to be disabled at any time.
        </para>
        <para>
          Another important point of the manager's event log facility is that
          loggers can also be marked as <emphasis>critical</emphasis>. Critical
          loggers are considered to be necessary if the experiment is to work.
          If a critical logger exits during data taking for any reason, the
          manager will force a state transition to SHUTDOWN.
        </para>
        <para>
          The <command>mg_cfgEvlog</command> utility allows you to create, edit
          and delete event log definitions.  Reference material for this
          utility is at
          <link linkend='daq1.mg_cfgevlog' endterm='daq1.mg_cfgevlog.title' />
        </para>
        <para>
            The event log editor GUI consists of a table of current event
            log definitions, a definition section below the table and two
            action buttons <guibutton>Save</guibutton> and <guibutton>Cancel</guibutton>
            Changes are not immediately saved to the database.  WHen you are
            satisfied with the definitions you see in the eventlog list,
            click <guibutton>Save</guibutton> to save those definitions oe
            <guibutton>Cancel</guibutton> if you don't want this work saved.
            <guibutton>Cancdel</guibutton> will simply reload the table with the
            event log definitions in the database.
          </para>
          <para>
            Items in the list of loggers have a context menu that can be posted by
            right clicking them.
            The context menu has the following commands:
          </para>
          <variablelist>
            <varlistentry>
               <term><literal>New</literal></term>
               <listitem>
                   <para>
                    Resets the event log editor form to its defaults.  The
                    action button in the form will be labeled <guibutton>Create</guibutton>
                    indicating that clicking it creates a new event logger definition.
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term><literal>Edit</literal></term>
               <listitem>
                   <para>
                    Loads the definition into the definition form and relabels its
                    action button <guibutton>Modify</guibutton> indiciating that
                    clicking it will modify the definition being edited.
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term><literal>Delete</literal></term>
               <listitem>
                   <para>
                    Deletes the definition under the pointer.
                   </para>
                </listitem>
            </varlistentry>
          </variablelist>
          <para>
            The Eventlog editor form contains the following elements:
          </para>
          <variablelist>
            <varlistentry>
               <term><literal>DAQRoot</literal></term>
               <listitem>
                   <para>
                    The NSCLDAQ installation directory root. This is loaded with the
                    directory root for the DAQ version from which the editor
                    was run.  It can be edited if there are special needs but,
                    in general, should not be earlier than 12.0-pre3.
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term><literal>Source</literal></term>
               <listitem>
                   <para>
                    Should be edited to be the URI of the ring buffer that will
                    be logged to disk.
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term><literal>Dest.</literal></term>
               <listitem>
                   <para>
                    Should be edited or browsed to the directory in which
                    data will be logged.  For partial loggers all data will
                    be logged into this directory.  For Complete loggers,
                    this is the top level of the directory tree maintained by
                    the logger.  See <literal>COMPLETE LOGGERS</literal>.
                   </para>
                   <para>
                    Note that if the event logger is containerized, this path must
                    be a valid path within the active container.
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term><literal>Host:</literal></term>
               <listitem>
                   <para>
                    Should be edited to the DNS name of the computer in which the
                    event logger will run.
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term><literal>Container</literal></term>
               <listitem>
                   <para>
                    Pulldown menu that allows you to select a container in which
                    the event logger runs.  Note that if this is empty, the logger
                    will run native.
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term><literal>Partial</literal></term>
               <listitem>
                   <para>
                    If checked, the logger will be a partial logger otherwise
                    it will be complete.
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term><literal>Critical</literal></term>
               <listitem>
                   <para>
                    If checked the logger is a critical component of the DAQ system
                    and unexpected exits will <literal>SHUTDOWN</literal> the
                    intire system.
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term><literal>Enabled</literal></term>
               <listitem>
                   <para>
                    If checked the logger is enabled.  If not it will not record
                    data even if the global recording is enabled.
                   </para>
                </listitem>
            </varlistentry>
          </variablelist>
          <para>
            Finally the edit form has an action button that is labeled
            <guibutton>Modify</guibutton> if clicking it will replace the definition
            that you initially loaded into the form using the <literal>Edit</literal>
             context menu or <guibutton>Create</guibutton> if it will create a
             new definition.
          </para>
     </section>
     <section>
        <title>The Key Value Store</title>
        <para>
          The manager configuration database file provides a key value store.
          You can think of this as an associative array of strings indexed by other strings.
          At present, there are two predefined keys.  You may create others as
          needed by your experiment:
        </para>
        <variablelist>
          <varlistentry>
             <term><literal>title</literal></term>
             <listitem>
                 <para>
                  This is used to set run titles in compatible
                  Readout programs.  It contains the desired title for the
                  next run.
               </para>
            </listitem>
          </varlistentry>
          <varlistentry>
             <term><literal>run</literal></term>
             <listitem>
                 <para>
                  Is used to set the run number in compatible Readout programs.
                  It contains the desired run number for the next run.
               </para>
            </listitem>
          </varlistentry>
        </variablelist>
        <para>
          The <command>mg_kvedit</command> command allows you to create, new keys,
          modify the values of existing keys and delete keys.  Be careful not
          to delete the keys described above.  Reference documentation for
          <command>mg_kvedit</command> is available at
          <link linkend='daq1.mg_kvedit' endterm='daq1.mg_kvedit.title' />
        </para>
        <para>
          The editor provides a window that, at the top, contains a table
          of key/value pairs.  At the bottom is an editing region that provides
          entries for a key and a value. Selecting (by clicking) a key value
          pair in the table loads the key and its value into the editor fields where
          either or both may be modified.  
        </para>
        <para>
          Clicking the <guibutton>Update</guibutton> button updates the table.
          If the key is an existing  key its value will be modified.  If it is
          a new key, a new key/value pair will be created. 
        </para>
        <para>
          Clicking on the <guibutton>Delete</guibutton> button removes a key
          and its value from the table.
        </para>
        <para>
          Note that none of the edits described above affect the database.
          The <guibutton>Save</guibutton> button writes all changes to the
          database key value table.
        </para>
     </section>
     <section>
        <title>User and Roles</title>
        <para>
          Note with NSCLDAQ-12.0, usrs and roles are not enforced by the manager.
          In later versions of the software, as we gain experience in its use,
          we will define a set of roles each with limited capabilities within the
          system.  The users in an experiment will be assigned roles and the
          interactions they can successfully perform will depend on the set of roles
          they hold.
      </para>  
        <para>
          The experiment configuration database does, however, already provide
          schema and configuration tools for defining the set of users for an
          experiment, the roles the system understands and granting and revoking
          roles to/from those users.  The program that supports configuring users
          and roles is <command>mg_authedit</command>.
          Reference information for <command>mg_authedit</command> can be found in
          <link linkend='daq1.mg_authedit' endterm='daq1.mg_authedit.title' />
        </para>
        <para>
          The important concepts to understand when configuring the authentication
          system are:
        </para>
        <variablelist>
          <varlistentry>
             <term>Authentication</term>
             <listitem>
                 <para>
                  Authentication is the act of logging into the system.  It requires
                  that you provide a valid user name and some secret information
                  that only you know (usually a password).  Two factor authentication
                  requires that you also provide some information that is time varying
                  and usually maintained by some third party.
               </para>
                 <para>
                  Authentication, establishes your identity to the computer system.
                  Nothing more.  Normally your identity is in the form of some
                  username and the associated groups that username belongs to.
                 </para>
            </listitem>
          </varlistentry>
          <varlistentry>
             <term>Authorization</term>
             <listitem>
                 <para>
                  Authorization allows access to some set of resources to a
                  authenticated user.  For example, file system permissions
                  allow and disallow specific users or groups of users types
                  of access to files or groups of files (directory permissions).
               </para>
            </listitem>
          </varlistentry>
          <varlistentry>
             <term>User</term>
             <listitem>
                 <para>
                  A user is an identity that can be authenticated. NSCLDAQ
                  users are simply computer system users.
               </para>
            </listitem>
          </varlistentry>
          <varlistentry>
             <term>Role</term>
             <listitem>
                 <para>
                  A role can be granted (or revoked) to a user of the
                  NSCLDAQ manager and will, when  implemented, authorize the user
                  the ability to perform specific types of operations in the experiment.
                  When a user has been granted a role, they are said to
                  <firstterm>hold</firstterm> that role.
               </para>
                 <para>
                  For example,
                  We may have a "Shift operator" role which allows holder to
                  start and stop runs or to set the run title or run number.
                  The fact that we have not actually figured out the appropriate
                  set of roles is why we also have not yet implemented
                  role basd permissions in the manager as of NSCLDAQ-12.0
                 </para>
            </listitem>
          </varlistentry>
        </variablelist>
        <para>
            The user interface of <command>mg_authedit</command> consists of
            the following sections:
          </para>
          <itemizedlist>
            <listitem>
               <para>
                  At the top is a tree view.  The top level items are users
                  that have been defined to the expermiment.  Second level
                  items (accessed by left clicking on the wedge icon to the left
                  of a user's name) are the roles held by that user.
               </para>
            </listitem>
            <listitem>
               <para>
                  Below the treeview is a section that allows you to add new users.
                  This is a frame with the lable <literal>Add user</literal>
               </para>
            </listitem>
            <listitem>
               <para>
                  Below the <literal>Add user</literal>  frame is a frame of
                  widgets that allows you to add and delete roles.  This frame
                  is labelled <literal>Add role</literal>.
               </para>
            </listitem>
            <listitem>
               <para>
                  At the bottom  of the user interface is a button labeled
                  <guibutton>Save</guibutton>.   All changes to the users and
                  roles and the roles granted to specific users are held within
                  the user interface until the <guibutton>Save</guibutton> button
                  is clicked.  
               </para>
               <para>
                To exit without saving updated roles and users, simply
                delete the window (on most window managers this means clicking)
                an <literal>X</literal> at the right top of the window banner.
               </para>
            </listitem>
          </itemizedlist>
          <para>
            The treeview supports context menus both on user and roles they've
            been granted.
            Right clicking on a user brings up a context menu with the
            following commands:
          </para>
          <variablelist>
            <varlistentry>
               <term><guimenuitem>Remove user...</guimenuitem></term>
               <listitem>
                   <para>
                    Prompts for confirmation and, if given, removes the user
                    and, of course.  This operation cleans up  properly, that is
                    first the user's roles are revoked and then the user
                    him/herself is removed from the list of authorized users.
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term><guimenuitem>Grant Roles...</guimenuitem></term>
               <listitem>
                   <para>
                    Pops up a list box populated with all of the roles the
                    user does <emphasis>not</emphasis> have.  The list box
                    supports multiple selection.  Select the rols you want to
                    grant and click the <guibutton>Ok</guibutton> button.
                    The <guibutton>Cancel</guibutton> button makes no changes
                    to the granted roles.
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term><guimenuitem>Revoke role(s)...</guimenuitem></term>
               <listitem>
                   <para>
                    Pops up a list box populated with the roles that have been
                    granted to the user.  Multiple selections are allowed.
                    Select the role(s) you wish to revoke from the user and
                    click <guibutton>Ok</guibutton> to revoke them.  The
                    <guibutton>Cancel</guibutton> button makes no changes
                    to the granted roles.
                   </para>
                </listitem>
            </varlistentry>
            
          </variablelist>
          <para>
            The context menu for a role can be accessed by right clicking on the
            role.  It contains the following menu commands.
          </para>
          <variablelist>
            <varlistentry>
               <term><guimenuitem>Revoke</guimenuitem></term>
               <listitem>
                   <para>
                    Revokes that role, and that role only, from the associated
                    user.
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term><guimenuitem>Grant role(s)...</guimenuitem></term>
               <listitem>
                   <para>
                    As with the user context menu, allows you to grant additional
                    roles to the user that holds this role.
                   </para>
                </listitem>
            </varlistentry>
          </variablelist>
          <para>
            The <literal>Add user</literal> frame allows you to add users to the
            list of authorized users. Simply type the username of the new
            authorized user and click the <guibutton>Add</guibutton> button
            to the right of the text entry.  If the user you type in is already
            in the authorized list, an error dialog will pop up to inform you
            of that.
          </para>
          <para>
            The <literal>Add role</literal> frame allows you to add and delete
            roles.  To add a role, simply type the new role name and click the
            <guibutton>add</guibutton> button. As with adding users,
            an error message will pop up if you type in an existing role name.
            
          </para>
          <para>
            To delete a role, simply click the <guibutton>Delete...</guibutton>
            button.  A list box will pop up populated with the names of all of the
            roles that have been defined.   Select thew role(s) to remove and click
            <guibutton>Ok</guibutton> to remove them.  Roles will be revoked from
            all that hold them before being deleted so no dangling role references
            will remain.  Clicking the <guibutton>Cancel</guibutton> button
            makes no changes.
          </para>
     </section>
  </section>
  <section id='sec.mgr.running'>
     <title id='sec.mgr.running.title'>Running an Experiment With The Manager</title>
     <para>
      This section will describe how to run an experiment with the manager.
      Subsequent sections:
      <link linkend='sec.mgr.readout' endterm='sec.mgr.readout.title' /> and
      <link linkend='sec.mgr.eventbuilder' endterm='sec.mgr.eventbuilder.title' />
      will describe how to configure Readout programs and the event builder for
      use within the manager framework.
     </para>
     <para>
      This section will describe the set of user interfaces that are available
      for use to shift operators while running the experiment.  Note that the
      client/server nature of the manager and these interfaces means that you
      can instantiate any number of these in the set of physical locations that
      are convenient.  You can also exit any of these user interfaces without
      affecting the run state.  For example, you can start a run in one location,
      kill off the run control panel, bring it up in another location and see
      that the run is continuing to acquire data, and then end the run from that
      second panel.
     </para>
     <para>
      All control panels we describe display state information.  Since the
      state information is gotten via polling, it will be consistent from
      panel to panel.
     </para>
     <para>
      The remainder of this section will describe the following contro panel:
     </para>
     <itemizedlist>
      <listitem>
         <para>
            <link linkend='sec.mgr.startstop' endterm='sec.mgr.startstop.title' />
            will describe how to start and stop the DAQ manager which is at the
            heart of this subsystem.
         </para>
      </listitem>
      <listitem>
         <para>
            <link linkend='sec.mgr.output' endterm='sec.mgr.output.title' />
            describes a control panel that monitors the output of all programs
            run by the manager.
         </para>
      </listitem>
      <listitem>
         <para>
            <link linkend='sec.mgr.runcontrol' endterm='sec.mgr.runcontrol.title' />
            describes the control panel you can use to control runs. 
         </para>
      </listitem>
      <listitem>
         <para>
            <link linkend='sec.mgr.eventbuilderstats' endterm='sec.mgr.eventbuilderstats.title' />
            provides the statistics of a single event builder.
         </para>
  
      </listitem>
      
     </itemizedlist>
     <para>
        Note that these control panels communicate with the manager and make use
        of the REST server interfaces in the Readout programs and the event builder
        to gather statistics information.  The
        sections
        <link linkend='sec.mgr.readout' endterm='sec.mgr.readout.title' />
        and <link linkend='sec.mgr.eventbuilder' endterm='sec.mgr.eventbuilder.title' />
        will describe how to run these under the manager so that they have this
        REST server interface enabled, as well as what to put in state transition
        sequences to run these programs under the manager.
      </para>
     <section id='sec.mgr.startstop'>
        <title id='sec.mgr.startstop.title'>Starting and Stopping the Manager</title>
        <para>
          Before any of the utilities described in the remaining sections can be
          used the experiment manager server must have been started.  Furhtermore,
          at the end of the experiment the manager should be shutdown to cleanup
          all of the programs it is managing in remote systems.  This
          section describes the utilities that perform these two tasks.
        </para>
        <para>
          The program
          <link linkend='daq1.mgr_startManager' endterm='daq1.mgr_startManager.title' />
          starts the manager in the system in which you are running.  This program
          only requires a single command line parameter; the configuration database
          file path.  
        </para>
        <para>
          The manager is fully a  background process and will continue to run,
          barring failures, until you explicitly stop it.  To communicate with it,
          in general, you'll need to know the DNS hostname of the system
           in which you started it and the name of the user that started it.
           In general experiments will be run by a collection of users. Before
           starting, agree on which of those will start the manager.
        </para>
        <para>
          There's really nothing to stop anybody with access to the configuration
          file from starting the manager.   As long as everybody knows who started
           the current instance of the manager and uses that username when
           interacting with it.
        </para>
        <para>
          Shutting down the server, like most operations, requires knowing the
          host the server is running in and the user that started the server.
          The
          <link linkend='daq1.mg_shutdown' endterm='daq1.mg_shutdown.title' />
          utility shuts down a DAQ manager server.  Note that this utility will,
          if necessary force a <literal>SHUTDOWN</literal> transition which,
          if the sequence(s) attached to that transition are properly written
          will stop all of the programs run by the system.
        </para>
        <para>
          If you shutdown the server when data taking is in progress,
          it's likely that you're going to have some cleanup work to do with
          the event loggers and the data they're writing as they won't see
          proper end of run records.
        </para>
     </section>
     <section id='sec.mgr.output'>
        <title id='sec.mgr.output.title'>The Output Monitor</title>
        <para>
          The DAQ manager server routinely runs program as it executes state transition
          sequences.  Some of these programs are transient an others persistent
          (critical programs are a subset of persistent programs).  
        </para>
        <para>
          When it
          runs a program, the DAQ manager arranges for the stdout and stderr
          output file descriptors to be directed at pipes that it can read.
          In addition to its REST server the manager provides a
          service named <literal>DAQManager-outputMonitor</literal>.
          The manager relays all output it receives from all programs that
          are currently running to clients of this service.  The data
          sent there are exactly the data recieved from programs.
        </para>
        <para>
          The <command>mg_monitorOutput</command> program, described in
          <link linkend='daq1.mg_monitorOutput' endterm='daq1.mg_monitorOutput.title' />
          provides a simple monitor of the output/error streams relayed by the
          manager.
        </para>
        
          <para>
            If the manager exits, or otherwise drops its connection to
            <command>mg_monitorOutput</command>, the program attempts to retry
            for some period of time and, if not successful, allows the user
            to retry once they are sure the manager is up and running or to exit
            if they are certain it won't be up in a reasonable time.
          </para>
          <para>
            The user interface consists of a menubar with a
            <guimenu>Settings</guimenu> menu. Below the menubar is a large
            text widget with a vertical scroll bar.  Output are appended to the
            end of the text in this text widget, as they are received from the
            manager.  A limited history of output is maintained and the scrollbar
            can be used to examine older output.  Below the output display
            is a status line that indicates whether or not the program is
            connected to the manager.
          </para>
          <para>
            The <guimenu>Settings</guimenu> menu provides commands that
            allow you to modify the settings of the output menu as well
            as the connection retry settings.  Let's look at the menu
            choices in this menu.
          </para>
          <variablelist>
            <varlistentry>
               <term><menuchoice><guimenu>Settings</guimenu><guimenuitem>OutputSettings...</guimenuitem></menuchoice></term>
               <listitem>
                   <para>
                    Provides a dialog that allows you to set the characterisics
                    of the output window.  The dialog provides a spinbox
                    that allows you to set the number of lines that are retained.
                    The checkbox labeled <literal>Show debugging otuput</literal>
                    is not used and is ignored a this time.
                   </para>
                   <para>
                    Set the history to the desired number of lines and then click
                    <guibutton>Ok</guibutton> to make the change or
                    <guibutton>Cancel</guibutton> to remove the dialog\
                    without making any changes.
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term><menuchoice><guimenu>Settings</guimenu><guimenuitem>Connection Settings...</guimenuitem></menuchoice></term>
               <listitem>
                   <para>
                    This brings up a dialog that describes what the program will
                    do when it loses connection with the manager.
                    If the connection is lost the program will attempt to
                    restablish its connection for a specified number of
                    <firstterm>retries</firstterm> at a specified
                    <firstterm>retry interval</firstterm>.
                    Once the retry count is exceeded, the program will prompt
                    for what to do next.
                   </para>
                   <para>
                    The menu selection pops up a dialog that allows you to
                    set both of these parameters.
                    The <literal>Retries before giving up</literal> spin box
                    sets the number of retries.  The
                    <literal>Time in secs between retries</literal> spin box
                    allows you to set the retry  interval  in seconds.
                   </para>
                   <para>
                    To accept the new paramters click <guibutton>OK</guibutton>
                    to reject them, click <guibutton>Cancel</guibutton>.
                   </para>
                </listitem>
            </varlistentry>
          </variablelist>
          
     </section>
     <section id='sec.mgr.runcontrol'>
        <title id='sec.mgr.runcontrol.title'>The Run Control Panel</title>
        <para>
          The run control panel application, <command>mg_RunControl</command>
          provides a control panel that can manage state transitions, run
          metadata, event logging and can monitor trigger statistics from
          compatible readout programs.
        </para>
        <para>
          Full reference information for this program is in
          <link linkend='daq1.rdo_RunControl' endterm='daq1.rdo_RunControl.title' />
          Note that unlike many of the manager control panels, in additionto
          needing the host on which the manager is running and the name of the
          user running it, this control panel must also be given the list of
          programs that run Readout REST interfaces.  This is used to maintain
          a status display of those programs as well as trigger statistics
          for each readout.
        </para>
        <para>
            The user interface is divided into roughly three sections.
            The top section provides the capability to monitor and modify run
            metadata.  This metadata inlcudes the current and next title as well
            as the current and next run.
          </para>
          <para>
            The middle section provides controls and status information
            to control state transitions in the manager and to monitor
            the aggregate state of the Readout programs.  This consists of
            three blocks of controls.  The left block supports booting and
            shutting down the experiment as well as monitoring the manager state.
          </para>
          <para>
            All state information is polled from the appropriate data source,
            therefore, if more than one control panel is run, all will show
            consistent state information regardless of which of thos panels
            changed system state.  For example if the user running one control panel
            changes the title, all other control panels will reflect that change
            after their next poll for status.  Status polling is approximately once
            per second.
          </para>
          <para>
            The middle block provides run control when the system is booted.
            It  always allows the system to be shutdown.  If the system can
            start a run a <guibutton>Begin</guibutton> button is present to do that.
            If the system is actively taking data an <guibutton>End</guibutton>
            button allows data taking to be halted.  A booted/idle system
            can also request that readout programs, that support this,
            re-initialize their hardware via the <guibutton>Initialize</guibutton>
            button.
          </para>
          <para>
            The <literal>State</literal> shown in this section is an aggregate
            state from all specified readouts.  If all Readouts report the same
            state, this state is reflected here.  If Readouts show differing states,
            the text <literal>inconsistent</literal> is displayed.  This can
            happen normally during state transitions as the Readouts asynchronously
            change state.
          </para>
          <para>
            Finally at the right hand side of the run controls section a
            checkbox labeled <literal>Recording</literal>, when checked informs
            the manager that eventloggers should be started when the run starts,
            recording data for that run.
          </para>
          <para>
            The bottom section of the user interface show the status of all of the
            readout programs described on the command line.  Note that if you miss
            one, it will still participate in run transitions if sequences are
            appropriately defined, as it is the sequences executed by the manager
            that are actually responsible for starting data taking in readout programs.
          </para>
          <para>
            The bottom section is a tabbed notebook. A single tab labeled
            <literal>summary</literal> provides a table of all of the readout
            programs specified on the command line.  Columns of the table provide
            the name of the program, the host  in which it runs, whether or not
            the program is responding to REST requests and the whether or not
            the manager thinks the program is running.
          </para>
          <para>
            Once the Readout programs start and become responsive to REST requests
            for the first time, additional tabs are created for them.  Each additional
            tab provides trigger statistics for one of the Readout programs.  The
            labels on these tabs will be of the form <replaceable>name@host</replaceable>
            where <replaceable>name</replaceable> is the program name and
            <replaceable>host</replaceable> is the host in which it runs.
          </para>
          <para>
            The statistics tabs will dynamically show the number of triggers,
            accepted triggers, and approximate bytes of data generated (event body
            sizes).  Both cumulative statistics (across all runs), and Statistics
            for the current run will be shown.  These statistics will update
            approximately every second.
          </para>
     </section>
     <section id='sec.mgr.eventbuilderstats'>
        <title id='sec.mgr.eventbuilderstats.title'>Event Builder Statistics Panel.</title>
        <para>
          When you use the manager with the event builder, it too will have
          a REST interface.  <link linkend='sec.mgr.eventbuilder' endterm='sec.mgr.eventbuilder.title' />
          describes how to set this up.  The <command>EVBMonitor</command> command
          provides a status panel that  dynamically displays the status and
          statistics for an event builder.  You can point any number of these
          status panels at an event builder.  At this point in time,
          each status panel can only display the status from one event builder.
        </para>
        <para>
          <link linkend='daq1.evbmonitor' endterm='daq1.evbmonitor.title' />
          provides reference information that describes the <command>EVBMonitor</command>
          program.  The remainder of this section will describe what it displays.
        </para>
        <para>
            Let's look at the user interface provided by the event builder monitor.
            The UI is divided into roughly three sections.  The top section is
            a tabbed notebook.  Each tab selects a different set of statistics
            exported by the event builder (more properly the orderer).
            The bottom left is a table listing the connected data sources.
            To the right of that is a status block.
          </para>
          <para>
            The tabbed notebook has the following tabs:
          </para>
          <variablelist>
            <varlistentry>
               <term><literal>Input Stats</literal></term>
               <listitem>
                   <para>
                    This page shows the input statistics of the event builder
                    and contains three counters.  The oldest timestamp
                    queued at any time.  The newest timestamp seen and the
                    number of queued fragments.  Note that when the number
                    of queued fragments drops to zero, the system does not
                    clear the Oldest timestamp counter.
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term><literal>Queue Stats</literal></term>
               <listitem>
                   <para>
                    Provides a table of the queue statistics.  Each line
                    represents the statistics of a single input queue.
                    The <literal>Id</literal> of the queue is the source id
                    associated with the event fragments that will be routed
                    to that queue.  
                   </para>
                   <para>
                    The <literal>Depth</literal>, <literal>Oldest</literal>
                    and <literal>Bytes</literal> are respectively, the number
                    of fragments queued in that queue, the timestamp of the
                    oldest fragment in the queue (fragment at the front of the
                    queue), and the number of bytes in the queue.
                   </para>
                   <para>
                    Finally the <literal>Dequeued</literal> and <literal>Queued</literal>
                    columns are the number of data bytes that have been dequeued
                    from the queue and queued to the queue respectively.  If the
                    depth is <literal>0</literal>, these two items should be equal.
                    In no case should <literal>Dequeued</literal> be greater than
                    <literal>Queued</literal>.
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term><literal>Barrier Stats</literal></term>
               <listitem>
                   <para>
                    This tab shows the top level barrier statistics.  Ideally,
                    when used with NSCLDAQ, all barriers will be complete and
                    homogeneous.  The complete barrier statistics are the first
                    row and contain, from left to right, the number of compete
                    barriers, the number of homogeneous barriers and the
                    number of heterogeneous barriers.  A heterogeneous barrier
                    is one where all queues received a barrier fragment within
                    the required barrier timeout, but there was more than one
                    barrier type.  
                   </para>
                   <para>
                    The second line provides the same information but for incomplete barriers.
                    An incomplete barrier is one where not all queues received
                    barrier fragments within the barrier timeout from the first
                    barrier received.
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term><literal>Complete Barriers</literal></term>
               <listitem>
                   <para>
                    Drills down into more details about the complete barriers
                    seen.  Note that a complete barrier <emphasis>could</emphasis>
                    be heterogenous.  The statistics in this page help to
                    untangle that case.
                   </para>
                   <para>
                    The display is a tree view.  There are two top level
                    elements of the tree; <literal>By Type</literal> that,
                    when expanded shows the number of each type of barrier
                    fragment that participated in a complete barrier, and
                    <literal>By Source</literal> which provides information
                    about the barriers received from each source.
                   </para>
                   <para>
                    The <literal>By Source</literal> top level, when expanded,
                    has another level for each data source id. When expanded,
                    that provides a list of the number of barriers of each
                    type that were contributed to complete barriers from that
                    source.
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term><literal>Incomplete Barriers</literal></term>
               <listitem>
                   <para>
                    This tab provides information about barriers that were
                    incomplete.  A barrier synchronization is incomplete if barrier
                    fragments were not received on all queues within the barrier
                    timeout of the first barrier fragment making its way to the
                    front of a queue.
                   </para>
                   <para>
                    This page is a tree view with two top levels.
                    The <literal>By # Missing</literal> when expanded,
                    shows the a count of the number of times a specific number
                    of fragments is missing.  For example, if a single data
                    source did not contribute a barrier once in the only incomplete
                    barrier seen, a subelement labeled <literal>1</literal> (one missing
                    fragment) will be added and the <literal>Count</literal>
                    column for it will display <literal>1</literal> (one time).
                   </para>
                   <para>
                    <literal>By Source id</literal> will have sub-entries for
                    each data source that failed barrier syncrhonization. THe
                    <literal>Count</literal> column will be the number of times
                    that source id did not make the barrier timeout.  In
                    the previous example, suppose the missing data source was
                    id 5.  This event will add a sub-entry labled 5 (the
                    id of the data source that missed the timeout) and
                    with a count of <literal>1</literal> (Missed it once).
                   </para>
                   <para>
                    Note that if a data source is slow getting its barriers in,
                    you'll see pairs of incomplete barriers, one for when all but
                    the slow source was present, and one for when the slow source
                    finally contributed its barrier fragment.
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term><literal>Data Late</literal></term>
               <listitem>
                   <para>
                    Provides the number of data late cases.  This increments
                    every time a fragment arrives but fragments with a later
                    timestamp have already been emitted. This display
                    is a table whose top line is the total number of times this
                    was detected and whose subsequent lines are the number of times
                    this was detected in fragments from specific data sources.  The
                    right most column shows the worst timestamp difference.
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term><literal>Out Of Order</literal></term>
               <listitem>
                   <para>
                    Summarizes the out of order timestamps.  An out of order
                    event is logged when a data source queue emits a fragment that
                    is older than the most recently emitted fragment.  This is
                    often coupled with a data late event.
                   </para>
                   <para>
                    The top row summarizes all data lates over all sources.  The
                    subsequent lines show data sources with non-zero data late
                    events.  The <literal>Count</literal> column is the number
                    of data late events seen. The <literal>Last Good TS</literal>
                    column show the timestamp of the fragment dequeued prior to
                    the one that was out of order and <literal>Offending TS</literal>
                    shows the timestamp from the fragment that was determined
                    to be out of order.
                   </para>
                </listitem>
            </varlistentry>
          </variablelist>
          <para>
            The connection list at the bottom left is a table of the
            connected data sources.  Each line provides the IP address in which the
            source is running, the connection description string of the source,
            the state of the source and the idle status.
          </para>
          <para>
            Finally, the status display shows if the Event builder has
            asserted flow control and if the UI is successfully updating.
            If the Event builder is not responding to update requests,
            a read <literal>Update failed</literal> will be displayed until
            updates work again.  This is normal if, for example, the data acquisition
            system is shutdown.
          </para>
     </section>
  </section>
  <section id='sec.mgr.readout'>
     <title id='sec.mgr.readout.title'>Running Readout Software With the Manager</title>
     <para>
      Running Readout programs under the DAQ manager requires the following:
     </para>
     <itemizedlist>
      <listitem>
         <para>
            Incorporating the REST control and status server into the Readout. 
         </para>
      </listitem>
      <listitem>
         <para>
            Providing a sequence entry to the manager on BEGIN that starts
            up the Readout.
         </para>
      </listitem>
      <listitem>
         <para>
            Providing sequence entries to the manager on BEGIN, HWINIT and END
            that properly start the run, request a hadware initialization and
            end the run.
         </para>
      </listitem>
     </itemizedlist>
     <para>
      Note that the current, initial version of the management utilities, do not
      support multiple Readouts in a single host, the mechanics are there but
      what is not there is the ability to specify REST Service names to the
      controlling utilities and control panels for each Readout.  We anticipate
      a later release of 12.x will provide this support.
     </para>
     <para>
      The remainder of this section will describe:
     </para>
     <itemizedlist>
      <listitem>
         <para>
            <link linkend='sec.mgr.bootreadout' endterm='sec.mgr.bootreadout.title' />
            describes how to setup Readout to run the REST plugin as a manager program and
            add it to
            a sequence attached to the BOOT transition.
         </para>
      </listitem>
      <listitem>
         <para>
            <link linkend='sec.mgr.readoutctl' endterm='sec.mgr.readoutctl.title' />
            describes the utilities that are available to control NSCLDAQ Readout
            programs that run the Readout REST server and how to use them in
            sequences attached to HWINIT, BEGIN, END and SHUTDOWN  to control
            the Readout program(s) that have been started at BOOT.
         </para>
      </listitem>
     </itemizedlist>
     <para>
        If your experiment runs more than one Readout you'll need to repeat the
        instructions in the following section, once for each Readout and
        most likely run the event builder as described in
        <link linkend='sec.mgr.eventbuilder' endterm='sec.mgr.eventbuilder.title' />
     </para>
     <section id='sec.mgr.bootreadout'>
        <title id='sec.mgr.bootreadout.title'>Starting Readout with REST at BOOT</title>
        <para>
          Starting Readout with a REST interface within the manager requires:
        </para>
        <orderedlist>
          <listitem>
             <para>
                Creating an initscript that is run by Readout as it starts
                to start the REST server.
             </para>
          </listitem>
          <listitem>
             <para>
                Specifying the Readout as a program to the manager. 
             </para>
          </listitem>
          <listitem>
             <para>
                Adding the Readout program to a sequence that's triggered
                by a BOOT transition.  We'll show how to create that sequence
                if it does not yet exist.  Note that any number of sequences
                can be triggered by a manager state transition.
             </para>
          </listitem>
        </orderedlist>
        <formalpara>
          <title>The Readout initscript.</title>
          <para>
            Readouts in the NSCLDAQ support initialization scripts.  These
            are Tcl scripts whose path is specified by the
            <option>--init-script</option> command line option.
            To start the REST server in Readout the following initscript
            is required:
          </para>
        </formalpara>
        <example>
          <title>Readout initscript to Start a REST server</title>
          <programlisting>
#
#  To override the default service name add a line like:
#
#   set ServiceName MyReadoutRESTService
package require ReadoutREST
close stdin
          </programlisting>
        </example>
        <para>
          The <command>package require</command> command starts the REST server.
          The default service name <literal>ReadoutREST</literal> is used
          unless this is overridden by defining the Tcl variable
          <varname>ServiceName</varname> or the environment variable
          <literal>SERVICE_NAME</literal> to be the desired service name.
        </para>
        <para>
          Once the REST service starts up, we close stdin so that we can
          continue to run if an endfile is detected on stdin.
        </para>
        <formalpara>
          <title>Specifying a Readout Program to the Manager.</title>
          <para>
            The program editor <link linkend='daq1.mg_cfgprogram' endterm='daq1.mg_cfgprogram.title' />
            or the experiment configuration editor
            (<link linkend='daq1.mg_config' endterm='daq1.mg_config.title' />)
            should be used to specify a Readout program to the editor:
            <orderedlist>
              <listitem>
                 <para>
                    Click the <guibutton>New...</guibutton>  button to bring
                    up the program editor to create a new program.
                 </para>
              </listitem>
              <listitem>
                 <para>
                     Fill in the top part of the definition:
                     Choose a unique name you will use to refer to this program
                     when buiding sequences.  If appropriate, select the container
                     in which the program will run.  Set for <literal>Program file:</literal>
                     the executable program or script that runs your Readout.
                     Note that if you are running within a container, this must
                     refer to a path within the container file system.  Set
                     the host in which the program will run and the working
                     directory in which it will run.  Mark the program as
                     <literal>Critical</literal>
                 </para>
                 <para>
                  Note that when running within a container, it can be useful
                  to define your container so that it has an initialization
                  script that sources the appropriate daqsetup.bash file.  If you
                  do that, since when running a program the manager writes a shell
                  script to run it, you can do environment name substitutions, e.g.
                  the program can be specified as <filename>$DAQBIN/DDASReadout</filename>.
                 </para>
              </listitem>
              <listitem>
                 <para>
                    Specify the program options you need for Readout by adding
                    them to the left list box.  At the very least you need
                    to specify <option>--inits-cript</option> to have a value
                    that is the path of your initialization script (within the
                    containerized filesystem if running containerized).
                    Depending on your data flow and if you are doing event building
                    you may also need to specify <option>--ring</option> and
                    <option>--sourceid</option>. 
                 </para>
              </listitem>
              <listitem>
                 <para>
                     Fill in the program environment.  At the very least, you'll
                     need to define <literal>TCLLIBPATH</literal> to point to the NSCLDAQ Tcl
                     package library directory tree
                     so that the <literal>ReadoutREST</literal> package
                     can be found.  If the <filename>daqsetup.bash</filename> has
                     been sourced, you can specify the value of that environment
                     variable to be <literal>$DAQTCLLIBS</literal>
                 </para>
              </listitem>
            </orderedlist>
          </para>
        </formalpara>
        <formalpara>
          <title>Starting your Readout From a Boot Sequencde</title>
          <para>
            In general, you will want to start your Readout program from a sequence
            that's triggered by the BOOT transition.  This will start your readout
            program as you tell the manager to bring up your data acquisition
            system.  Use
            <link linkend='daq1.mg_seqedit' endterm='daq1.mg_seqedit.title' />
            (or start it from
            <link linkend='daq1.mg_config' endterm='daq1.mg_config.title' />)
            to do this.  If no sequence has been specified to trigger on Boot,
            you need to create one by typing a unique sequence name
            (I suggest <literal>BOOT)</literal>) in the <literal>New Sequence:</literal>
            entry box and selecting <literal>BOOT</literal> from the
            <literal>Trigger state:</literal> drop down.  Then
            click <guibutton>Add</guibutton> to add it to the list of sequences.
            Once you have done this:
            <orderedlist>
              <listitem>
                 <para>
                    Double click the sequence triggered on boot to bring up
                    the sequence editor.
                 </para>
              </listitem>
              <listitem>
                 <para>
                    In the <literal>Define step</literal>  frame choose your
                    readout program from the <literal>Program name</literal>
                    drop down list.
                 </para>
              </listitem>
              <listitem>
                 <para>
                    Click <guibutton>Add</guibutton> to add the program
                    to the end of list of actions performed by this sequence.
                    In general, you won't need either a pre or post delay so you
                    can leave these defaulted to zero.
                 </para>
              </listitem>
            </orderedlist>
          </para>
        </formalpara>
     </section>
     <section id='sec.mgr.readoutctl'>
        <title id='sec.mgr.readoutctl.title'>Controlling Readout From the Manager</title>
        <para>
          In the previous section we saw how to add a Readout program to the
          manager and arrange for it to start when the DAQ system boots.
          In this section we'll describe how to ensure that the manager
        </para>
        <orderedlist>
          <listitem>
             <para>
                Starts any event loggers you've defined when a run begins. 
             </para>
          </listitem>
          <listitem>
             <para>
                Sets the run metadata (title, run number) in all readout
                programs when the run begins.
             </para>
          </listitem>
          <listitem>
             <para>
                Tells the readout programs to begin taking data when a run begins
             </para>
          </listitem>
          <listitem>
             <para>
                Tells the Readout programs to stop taking data when a run ends. 
             </para>
          </listitem>
          <listitem>
             <para>
                Provides support for hardware initialization if needed for eeach
                readout.
             </para>
          </listitem>
        </orderedlist>
        <para>
          Note that for some complex data acquisition systems you will need
          to think about the order in which each Readout starts/stops taking data and
          may need to also think about how to arrange for timestamp synchronization.
        </para>
        <para>
          The manager provides a number of utilities to help you build sequences
          that control data taking.  These are:
        </para>
        <variablelist>
          <varlistentry>
             <term><link linkend='daq1.mg_startloggers' endterm='daq1.mg_startloggers.title' /></term>
             <listitem>
                 <para>
                  This program starts all event loggers you have defined
                  for your experiment.  All loggers run for the duration of a single
                  run.  The loggers will only start if global event recording
                  is enabled and each logger will then only start if it is enabled.
               </para>
               <para>
                Normally event logger must be started in a <literal>BEGIN</literal>
                sequence before any of the readouts are allowed to take data.
               </para>
            </listitem>
          </varlistentry>
          <varlistentry>
             <term>
              <link linkend='daq1.rdo_runFromKv' endterm='daq1.rdo_runFromKv.title' />
             </term>
             <listitem>
                 <para>
                  Asks a single readout program to set its run number to the
                  value of the <literal>run</literal> variable in the key
                  value store.  This should be done in each Readout program
                  prior to starting data taking so that they all have
                  consistent run numbers that match the value of
                  that variable.  This variable is maintained by the
                  Run control panel.
               </para>
            </listitem>
          </varlistentry>
          <varlistentry>
             <term>
              <link linkend='daq1.rdo_titleFromKv' endterm='daq1.rdo_titleFromKv.title' />
             </term>
             <listitem>
                 <para>
                  Asks a single readout program to set it stitle to the value of
                  the <literal>title</literal> key in the key value store.  This
                  should be done in each Readout program prior to starting a run
                  so that they all have the same title.  This should be
                  done in the sequence prior to starting data taking.
                  This variable is maintained by the Run control panel.
               </para>
            </listitem>
          </varlistentry>
          <varlistentry>
             <term>
              <link linkend='daq1.rdo_control' endterm='daq1.rdo_control.title' />
             </term>
             <listitem>
                 <para>
                  Performs some operation on a single Readout program.
                  We're going to use the <literal>init</literal>,
                  <literal>begin</literal>,  <literal>end</literal> and
                  <literal>shutdown</literal> subcommands.
               </para>
            </listitem>
          </varlistentry>
        </variablelist>
        <para>
          The remainder of this section will show:
        </para>
        <itemizedlist>
          <listitem>
             <para>
                What to put in a sequence triggered on
                <literal>SHUTDOWN</literal>to stop
                your Readouts.
             </para>
          </listitem>
          <listitem>
             <para>
                What to put in a sequence triggered on
                <literal>BEGIN</literal>to start taking
                data.
             </para>
          </listitem>
          <listitem>
             <para>
                What to put in a sequence triggered on
                <literal>HWINIT</literal> to ask the Readouts to intialize
                their hardware.
             </para>
          </listitem>
          <listitem>
             <para>
                What to put in a sequence tirggered on
                <literal>END</literal> to end data taking in your Readouts.
             </para>
          </listitem>
        </itemizedlist>
        <para>
          To cut down on explanatory text, we're going to assume:
        </para>
        <itemizedlist>
          <listitem>
             <para>
                The manager is running in a system called <literal>daqcompute1</literal>
                and was or will be started by <literal>fox</literal>.
             </para>
          </listitem>
          <listitem>
             <para>
                There's only one readout and its run in a system called
                <literal>spdaq99</literal> and its program name is <literal>readout99</literal>
             </para>
          </listitem>
          <listitem>
             <para>
                Following the instructions in the previous section, we've already
                set up a <literal>BOOT</literal> sequence that starts our
                Readout when the system is booted.
             </para>
          </listitem>
          <listitem>
             <para>
                We're running containerized in a container named
                <literal>BUSTER</literal> and the initscript of that
                container sources an appropriate <filename>daqsetup.bash</filename>
                so all of the DAQ Environment variables are availalble.
             </para>
          </listitem>
        </itemizedlist>
        <formalpara>
          <title><literal>SHUTDOWN</literal> sequence</title>
          <para>
            We need to create a program that shuts down our <literal>readout99</literal>
            Readout program and put it in a sequence that is triggered by the
            <literal>SHUTDOWN</literal> transition:
            <orderedlist>
              <listitem>
                 <para>
                    Use the program editor
                    <link linkend='daq1.mg_cfgprogram' endterm='daq1.mg_cfgprogram.title' />
                    to create a new program named
                    <literal>shutdown99</literal> let's run it in <literal>daqcompute1</literal>,
                    although it could run anywhere.  Specify the <literal>buster</literal>
                    container, any working directory and the program file will be
                    <literal>$DAQBIN/rdo_control</literal>.  The program should be
                    marked 
                 </para>
                 <para>
                  Parameters must be in order: <literal>spdaq99</literal> (the
                  system readout99 runs in), <literal>fox</literal> and
                  <literal>shutdown</literal>.
                 </para>
                 <para>
                  Save this program definition by clicking <guibutton>Ok</guibutton>.
                  This creates a nw program, <literal>shutdown99</literal>
                  that will ask the readout program in <literal>spdaq99</literal>
                  run by <literal>fox</literal> to exit.
                 </para>
              </listitem>
              <listitem>
                 <para>
                     Use the sequence editor,
                     <link linkend='daq1.mg_seqedit' endterm='daq1.mg_seqedit.title' />
                     to, if necessary  create a sequence triggered on the
                     <literal>SHUTDOWN</literal> transition.  Double click on that
                     sequence to edit its steps.
                 </para>
                 <para>
                  Add a step that runs the <literal>shutdown99</literal> program
                   you just created to the sequence.
                 </para>
              </listitem>
            </orderedlist>
          </para>
        </formalpara>
        <formalpara>
          <title>Telling the Manager to Begin a Run in readout99</title>
          <para>
            We need to create programs to set the run number, Set the title and
            begin the run:
            <orderedlist>
              <listitem>
                 <para>
                     In the program editor, create a new program name it
                     <literal>setrun99</literal> it will run in
                     <literal>daqcomput1</literal>, under the <literal>buster</literal>
                     container and will execute
                     <literal>$DAQBIN/rdo_runFromKv</literal>.  This program
                     should be marked transitory.  It's parameters should, in order,
                     be: <literal>spdaq99</literal>, <literal>fox</literal>,
                     <literal>readout99</literal>
                 </para>
                 <para>
                  You can choose any existing directory for the working
                  directory.
                 </para>
              </listitem>
              <listitem>
                 <para>
                    Similarly create a new program <literal>settitle99</literal>
                    everthing should be the same as the previous step, however,
                    the program file will be <literal>$DAQBIN/rdo_titleFromKv</literal>
                    this program should also be transitory.
                 </para>
              </listitem>
              <listitem>
                 <para>
                     Finally add a new program named <literal>begin99</literal>
                     Only the program file and parameters will be different
                     from the programs above:  For the program  file
                     use <literal>$DAQBIN/rdo_control</literal>, for
                     the parameters use, in order:
                     <literal>spdaq99</literal>, <literal>fox</literal> and
                     <literal>begin</literal>.
                 </para>
                 <para>
                  This creates a program that requests that our readout running
                  in spdaq99 begin a run.
                 </para>
              </listitem>
              <listitem>
                 <para>
                    Finally, using the sequence editor; if necessary, create a sequence
                    that is triggered by the <literal>BEGIN</literal>
                    transition add, in order, the <literal>setrun99</literal>,
                    <literal>settitle99</literal> and <literal>begin99</literal>
                    programs you created in the steps above.  These sequence steps
                    will set the run number and title from the values in the
                    key value store and then start the run in the Readout
                    program.
                 </para>
              </listitem>
            </orderedlist>            
          </para>
        </formalpara>
        <formalpara>
          <title>Handling <literal>HWINIT</literal> Transitions</title>
          <para>
            When an <literal>HWINIT</literal> transition is performed, we want
            to tell <literal>readout99</literal> to initialize its hardware,
            if it supports doing that:
            <orderedlist>
              <listitem>
                 <para>
                    Create a new program <literal>hwinit99</literal>.  It should
                    run in the <literal>buster</literal> container, be marked
                    transitory and run in <literal>daqcompute1</literal>.
                    The progam file should be <literal>$DAQBIN/rdo_control</literal>.
                    The parameters should be, in order,
                    <literal>spdaq99</literal>, <literal>fox</literal> and
                    <literal>init</literal>
                 </para>
              </listitem>
              <listitem>
                 <para>
                    Using the sequence editor, if necessary add a sequence that is
                    triggered by the <literal>HWINIT</literal> transition.
                    Add <literal>hwinit99</literal> to that sequence.
                 </para>
              </listitem>
            </orderedlist>
          </para>
        </formalpara>
        <formalpara>
          <title><literal>END</literal> Transitions and Stopping Data Taking</title>
          <para>
            To end the run when the manager undertakes a <literal>END</literal>
            transition:
            <orderedlist>
              <listitem>
                 <para>
                    Create a new program with the program editor
                    named <literal>end99</literal>.  The program file should
                    be <literal>$DAQBIN/rdo_control</literal>, the container
                    <literal>buster</literal>, the host <literal>daqcompute1</literal>.
                    The program should be marked transitory and its parameters,
                    in order must be
                    <literal>spdaq99</literal>, <literal>fox</literal> and
                    <literal>end</literal>
                 </para>
              </listitem>
            </orderedlist>
          </para>
        </formalpara>
     </section>
  </section>
  <section id='sec.mgr.eventbuilder'>
     <title id='sec.mgr.eventbuilder.title'>Using the NSCLDAQ Event Builder With the Manager</title>
     <para>
      This section describes how to run the NSCLDAQ event builder from the
      NSCLDAQ manager.  Unlike the ReadoutGUI, where the event builder was often
      run in one-shot mode, we suggest running the Event builder in persitent
      mode under the manager.
     </para>
     <para>
      This requires:
     </para>
     <orderedlist>
      <listitem>
         <para>
            You create a program to start the event builder with its
            REST statistics plugin
         </para>
      </listitem>
      <listitem>
         <para>
            You create program definitions for each data source. 
         </para>
      </listitem>
      <listitem>
         <para>
            You add these programs to a sequence that's executed by the
            <literal>BOOT</literal> transition
         </para>
      </listitem>
      <listitem>
         <para>
            Create a program to shutdown the event builder (the sources
            will shutdown when their network peer exits).
         </para>
      </listitem>
      <listitem>
         <para>
            Add the shutdown program to a sequence that's executed
            by the <literal>SHUTDOWN</literal> transition.
         </para>
      </listitem>
     </orderedlist>
     <para>
      In the remainder of this section we will show how to execute the steps
      above.
     </para>
     <formalpara>
      <title>Create a Program To Start The Event Builder.</title>
      <para>
        In fact, the event builder is a pipeline of programs.  An Orderer which
        accepts fragments from data sources and outputs them totally time ordered
        to stdout, <command>glom</command> which glues together fragments into
        events and sends those events to its stdout, and finally
        <command>stdintoring</command> which drops the ring items 
        <command>glom</command> built to a ringbuffer for distribution.
      </para>
     </formalpara>
     <para>
      You will need to build a script that starts up this pipeline and define
      it as a program to the manager.  The following sample script does that
      building events with a timestamp window of <literal>250</literal>
      ticks and dropping events into the ringbuffer <literal>fox_evb</literal>.
     </para>
     <example>
      <title>An Event Builder Start Script</title>
      <programlisting>
#!/bin/bash


TCLLIBPATH=$DAQTCLLIBS $DAQBIN/EVBRest  \
  | $DAQBIN/glom --dt 250  \
  | $DAQBIN/stdintoring fox_evb

      </programlisting>
     </example>
     <para>
      This script assumes the appropriate  <filename>daqsetup.bash</filename>
      script has been sourced.   The first stage of the pipeline runs
      the <link linkend='daq1.EVBRest' endterm='daq1.EVBRest.title' />
      program which runs the orderer stage with a REST interface plugin.
      The second stage of the pipeline run the <command>glom</command> program
      described in
      <link linkend='daq1.glom' endterm='daq1.glom.title' />.
      The <option>--dt</option><literal> 250</literal> option sets the
      build window to 250 timestamp ticks.  The final pipline stage takes the
      output of glom and puts the ring items it produced into the ring named
      <literal>fox_evb</literal>.
     </para>
     <para>
      Use <link linkend='daq1.mg_cfgprogram' endterm='daq1.mg_cfgprogram.title' />
      to create a program that runs this script.  Be sure to chmod the
      script so that it is executable by whomever will run the manager.
      In the remaining discussion, we'll assume this program was given the name
      <literal>startevb</literal>.
     </para>
     <para>
      Specify the name of the program as <literal>startevb</literal>, specify
      the name of the script you created for the filename.  Specify appropriate
      container, working directory and host values.  Generally, event builders
      should be marked as <literal>Critical</literal> programs.  
     </para>
     <para>
      You should not normally require any options, parameters or environhment
      variables.   These will be provided in your script.
     </para>
     <formalpara>
      <title>Making a Program to Start a Data Source</title>
      <para>
        This discussion assumes that the data comes from
        <literal>tcp://spdaq99/fox</literal>.  We also assume the source ids
        are the default value of <literal>0</literal>.  Finally we assume that
        the program will run in an evironment with an appropriate
        <filename>daqsetup.bash</filename> sourced in.
      </para>
     </formalpara>
     <para>
      In the program editor set the name to e.g. <literal>source99</literal>
      Set the host to the name of the host in which you want the source to run.
      Choose an appropriate container definition if appropriate.  Chose
      any working directory and mark the progrfam as Critical.
     </para>
     <para>
      The following options should be specified:
     </para>
     <variablelist>
      <varlistentry>
         <term><option>--evbhost</option></term>
         <listitem>
             <para>
              Host in which the event builder pipeline will run.
           </para>
        </listitem>
      </varlistentry>
      <varlistentry>
         <term><option>--evbname</option></term>
         <listitem>
             <para>
              Set this to the name of the user running the manager.
           </para>
        </listitem>
      </varlistentry>
      <varlistentry>
         <term><option>--info</option></term>
         <listitem>
             <para>
              Set this to a descriptive string. E.g:
              <literal>"spdaq99\ data"</literal>
           </para>
        </listitem>
      </varlistentry>
      <varlistentry>
         <term>--ids</term>
         <listitem>
             <para>
              There should be one of these for each source id the source will
              emit.  The value should be the value of one of those ids.
              Note that most NSCLDAQ Readout programs only emit a single source id.
              A notable exception being the CAEN Digitizer readouts which emit
              a source id per digitizer.
           </para>
        </listitem>
      </varlistentry>
      <varlistentry>
         <term><option>--ring</option></term>
         <listitem>
             <para>
              The URI from which the data comes.  In our example the value is
              <literal>tcp://spdaq99/fox</literal>
           </para>
        </listitem>
      </varlistentry>
      <varlistentry>
         <term><option>--expectbodyheaders</option></term>
         <listitem>
             <para>
              No value required.  This indicates the data come from an 11.0
              NSCLDAQ or later.
           </para>
        </listitem>
      </varlistentry>
      <varlistentry>
         <term><option>--oneshot</option><literal>=0</literal></term>
         <listitem>
             <para>
              Indicates the data source should not exit after an end of run
              condition.
           </para>
        </listitem>
      </varlistentry>
     </variablelist>
     <para>
      For more information; see
      <link linkend='daq1.ringfragsource' endterm='daq1.ringfragsource.title' />
     </para>
     <formalpara>
      <title>Starting the Event Builder and Source(s) In a Boot Sequence</title>
      <para>
        Now that you have your start programs, <literal>startevb</literal>
        to start the event builder pipeline and <literal>source99</literal>
        to start the data source, using the sequence editor
        (<link linkend='daq1.mg_seqedit' endterm='daq1.mg_seqedit.title' />),
        If necessary create a sequence triggered by the BOOT transition.
        Add the <literal>startevb</literal> program to it and then add
        the <literal>source99</literal> program with a pre-delay of 5 seconds
        so that the event builder has a chance to register and listen for
        connections on its REST service before <command>ringFragmentSource</command>
        tries to look up the service.
      </para>
     </formalpara>
     <formalpara>
      <title>Making a Program to Shutdown The Event Builder</title>
      <para>
        The <link linkend='daq1.EVBShutdown' endterm='daq1.EVBShutdown.title' />
        utility shuts down an event builder that is running a REST interface.
        Use <link linkend='daq1.mg_cfgprogram' endterm='daq1.mg_cfgprogram.title' />
        to add a program.  Name it <literal>evbshutdown</literal>, run the
        prgram file <literal>$DAQBIN/EVBShutdown</literal>.  Set the host,
        working directory and container appropriately.
      </para>
     </formalpara>
     <para>
      The program parameters should be, in order, the host in which the
      event builder pipeline is running and the user running it.  This is
      the host you specified the <literal>startevb</literal> program to run in.
      The user should be the user that will run the daq manager.
     </para>
     <para>
      Note that shutting down the event builder pipeline will, eventually
      shutdown the data sources as they lose connection to the event builder.
     </para>
     <formalpara>
      <title>Adding the Event Builder Shutdown to a SHUTDOWN Sequence </title>
      <para>
        Using <link linkend='daq1.mg_seqedit' endterm='daq1.mg_seqedit.title' />
        if necessary, add a squence triggered on the <literal>SHUTDOWN</literal>
        transition.  Edit that sequence and add the
        <literal>evbshutdown</literal> program to that sequence.
      </para>
     </formalpara>
  </section>
</chapter>
<!-- /chapter -->

<!-- manpage 1daq -->
<refentry id='daq1.mg_mkconfig'>
   <refmeta>
      <refentrytitle id='daq1.mg_mkconfig.title'>mg_mkconfig</refentrytitle>
      <manvolnum>1daq</manvolnum>
   </refmeta>
   <refnamediv>
      <refname>mg_mkconfig</refname>
      <refpurpose>Create NSCLDAQ Manager ConfigurationDatabase</refpurpose>
    </refnamediv>
    <refsynopsisdiv>
      <cmdsynopsis>
        <command>
$DAQBIN/mg_mkconfig <replaceable>config-file</replaceable>
        </command>
      </cmdsynopsis>
    </refsynopsisdiv>
    
    <refsect1>
             <title>DESCRIPTION</title>
          <para>
            Creates an NSCLDAQ manager configuration database file into the named
            <filename>config-file</filename>.  The command creates all of the
            tables, indices and other schema elements required by the manager
            as well stocking initial values into the database tables.
          </para>
          <para>
            It is safe to run the command on an existing database and, if the
            schema change, that is the recommended way to convert an older
            database file to more recent version. 
          </para>
          <para>
            Iit is also safe to run the command on an existing database file that
            does not have a conflicting schema providing support to extend configuration
            databases to contain experiment metadata the manager is blind to.
          </para>
    </refsect1>
    <refsect1>
      <title>EXAMPLES</title>
      <informalexample>
        <programlisting>
$DAQBIN/mg_mkconfig e2022-config.db
        </programlisting>
      </informalexample>
      <para>
        Creates a manager configuration database file into
        <filename>e2022-config.db</filename> in the current workingdirectory.
      </para>
    </refsect1>
</refentry>
<refentry id='daq1.mg_config'>
   <refmeta>
      <refentrytitle id='daq1.mg_config.title'>mg_config</refentrytitle>
      <manvolnum>1daq</manvolnum>
   </refmeta>
   <refnamediv>
      <refname>mg_config</refname>
      <refpurpose>Launcher for all manager configuration editors.</refpurpose>
    </refnamediv>
    <refsynopsisdiv>
      <cmdsynopsis>
        <command>
$DAQBIN/mg_config <replaceable>configuration-file</replaceable>
        </command>
      </cmdsynopsis>
    </refsynopsisdiv>
    <refsect1>
             <title>DESCRIPTION</title>
          <para>
            Launches program that can, in turn, launch the configuration
            GUI tools for the NSCLDAQ manager subsystem.  The user interface
            consists primarily of a listbox. Double clicking an entry in the
            list launches the corresponding configuration utility:
          </para>
          <itemizedlist>
            <listitem>
               <para>
                  <literal>Users and Roles</literal>  launches the
                  configuration editor for the authorization subsystem.
               </para>
            </listitem>
            <listitem>
               <para>
                  <literal>Containers</literal>  launches the configuration
                  editor for container definitions
               </para>
            </listitem>
            <listitem>
               <para>
                  <literal>Programs</literal> launches the program configuration
                  editor.
               </para> 
            </listitem>
            <listitem>
               <para>
                  <literal>Event logging</literal>  launches the event log editor.
                  Event loggers are a special type of program given their
                  need to be transient but potentially critical.
               </para>
            </listitem>
            <listitem>
               <para>
                  <literal>State Machine</literal> launches a state machine editor.
                  In most applications you will not need this editor, as the
                  database is pre-populated with the state machine appropriate
                  for NSCLDAQ.
               </para>
            </listitem>
            <listitem>
               <para>
                  <literal>Sequence Definition</literal>  launches the sequence
                  editor that provides the capability to create sequences
                  that are triggered by state transitions and the steps performed
                  by those sequences.
               </para>
            </listitem>
            <listitem>
               <para>
                  <literal>Key Value store</literal>  launches an editor that
                  allows you to create and delete keys in the key value store
                  as well as to modify the values of existing keys.  Be very
                  careful when deleting keys as steps in sequences may depend
                  on the values of some of those keys.  For example the
                  <literal>run</literal> and <literal>title</literal> keys
                  are typically used to set the run number and title for
                  Readout programs that are NSCLDAQ compatible.
               </para>
            </listitem>
          </itemizedlist>
    </refsect1>
</refentry>

<refentry id='daq1.mg_cfgcontainers'>
   <refmeta>
      <refentrytitle id='daq1.mg_cfgcontainers.title'>mg_cfgcontainers</refentrytitle>
      <manvolnum>1daq</manvolnum>
   </refmeta>
   <refnamediv>
      <refname>mg_cfgcontainers</refname>
      <refpurpose>Configure the containers known to the NSCLDAQ manager</refpurpose>
    </refnamediv>
    <refsynopsisdiv>
      <cmdsynopsis><command>
$DAQBIN/mg_cfgcontainers <replaceable>config-file</replaceable>
      </command></cmdsynopsis>
    </refsynopsisdiv>
    <refsect1>
             <title>DESCRIPTION</title>
          <para>
            Graphical user interface to configure container definitions for
            the NSCLDAQ manager subsystem.
            <filename>config-file</filename> is the path to the configuration
            database file.
          </para>
          <para>
            The top level window of this program is a list of container names on the
            left side and a list of filesystem bindings on the right. Clicking
            a container name populates the bindings list box with the bindings
            for the seleted container.  
          </para>
          <para>
            Clicking the <guibutton>Init Script..</guibutton> button displays the
            initialization script for the container.  The initialization script is
            a script that is run prior to running every program in the container.
            It allows you to perform common environment setup operations (e.g.
            sourcing the correct <filename>daqconfig.bash</filename> file).
            The <emphasis>contents</emphasis> of the configuration file are
            stored in the database so that the initialization script is stable
            under edits to the original file.
          </para>
          <para>
            The <guibutton>New...</guibutton> and <guibutton>Edit...</guibutton>
            bring up a dialog that allows you to define a container.  The
            only difference between the two buttons is that <guibutton>Edit...</guibutton>
            pre-populates the dialog with the definition of the selected container.
            You can use this dialog to set the container image file, add/remove
            bindings, set the container name, and pull in the contents of
            an initialization script.
          </para>
          <para>
             When the <guibutton>Ok</guibutton> button is clicked, the definition
             is saved.  If <guibutton>Cancel</guibutton> is clicked, the
             definition is discarded.  
          </para>
          <para>
            When the dialog is brought up with
             <guibutton>Edit...</guibutton> <guibutton>Cancel</guibutton> retains
             the old definition.  Furthermore if <guibutton>Ok</guibutton> is clicked
             but you change the name of the container, a new container defintion
             is created using that name.  This allows you to create a new
             container definition beginning with the definition of an existing
             container as a starting point.
          </para>
          <para>
            When the dialog is brought up with the <guibutton>New...</guibutton>,
            <guibutton>Cancel</guibutton> makes no changes to the database,
            <guibutton>Ok</guibutton> saves the new container definition.
            Take care not to duplicate the name of an existing container.
          </para>
          <para>
            Note that the <guibutton>Ok</guibutton> button directly modifies
            the database.  This is why there is no <guibutton>Save</guibutton>
            button on the main window.
          </para>
    </refsect1>
</refentry>

<refentry id='daq1.mg_cfgprogram'>
   <refmeta>
      <refentrytitle  id='daq1.mg_cfgprogram.title'>mg_cfgprogram</refentrytitle>
      <manvolnum>1daq</manvolnum>
   </refmeta>
   <refnamediv>
      <refname>mg_cfgprogram</refname>
      <refpurpose>Configure manager program definitions</refpurpose>
    </refnamediv>
    <refsynopsisdiv>
      <cmdsynopsis><command>
$DAQBIN/mg_cfgprogram <replaceable>configuration-file</replaceable>
      </command></cmdsynopsis>
    </refsynopsisdiv>
    <refsect1>
             <title>DESCRIPTION</title>
          <para>
            <command>mg_cfgprogram</command> is a utility that supports editing
            DAQ manager program definitions.
            The <filename>configuration-file</filename> command line parameter
            is the path of the configuration database file that will be edited.
          </para>
          <para>
            The main window of this editor is a table listing the programs that are
            currently defined.  The program name, program file, host and container
            of all defined programs are shown in this table.  If the Container
            column is empty for a program it is run natively in the specified host.
            Note, as you might expect, for containerized applications, the
            program file is the path to the program as it appears in the container
            file system.  Not the host filesystem.
          </para>
          <para>
            CLicking the <guibutton>New..</guibutton> button or double clicking
            on a program in the table, brings up an editor window.  The only
            difference between the two methods to bring up this window are that
            double clicking a program will load that program into the editor
            window.
          </para>
          <para>
            For the most part the editor window is straightforward, the Name
            of the program must be a unique name.  The program file
            <guibutton>Browse...</guibutton> button allows you to browse for
            the program file.  This browses in the filesystem in effect at the
            time the editor is being run.  If, for example, you are running the
            editor natively but the program will be containerized,
            you may need to modify the final path selected by hand to match
            what the container sees.  The Container <guibutton>Browse...</guibutton>
            buttons allows you to select from the list of defined containers in
            which the program can run.
          </para>
          <para>
            A <literal>Type</literal> radio button group allows you to specify
            the program type.
          </para>
          <para>
            The <literal>Program Options</literal> listbox shows the options
            that are defined for the program.  To add a new option,
            enter the option namme (e.g. <literal>--ring</literal>) and
            option value (e.g. <literal>fox</literal>) in the Name and Value
            entry text boxes and click the <guibutton>New</guibutton> button.
            To remove an option  click it in the list, this also supports
            editing the option as the name/value pair are loaded into the
            corresponding entries where they can be edited and recreated.
            This bit of mechanics is the same for all of the editor elements
            described below.
          </para>
          <para>
            Similarly, the <literal>Program Parameters</literal> listbox
            shows parameters that are passed to the program.  You can think of
            parameters as options with no value.  However, the program parameters
            are passed to the program <emphasis>after</emphasis> the program's
            options.   Create a new parameter by entering its value and clicking
            the <guibutton>New</guibutton> button below it.  Delete or edit
            by clicking it in the list.  Note that often parameters are positional
            and you must take care of that when editing.
          </para>
          <para>
            The <literal>Program Environment</literal> define environment
            variables that will be defined when the program executes.
            Editing these is identical to editing <literal>Program Options:</literal>
          </para>
          <para>
            Clicking <guibutton>OK</guibutton> saves the definition in the database
            and refreshes the list of programs in the main window.
            Clicking <guibutton>Cancel</guibutton> closes the editor window
            without making any changes
          </para>
    </refsect1>
</refentry>
 
<refentry id='daq1.mg_stateedit'>
   <refmeta>
      <refentrytitle id='daq1.mg_stateedit.title'>mg_stateedit</refentrytitle>
      <manvolnum>1daq</manvolnum>
   </refmeta>
   <refnamediv>
      <refname>mg_stateedit</refname>
      <refpurpose>Edit DAQ Manager state machine</refpurpose>
    </refnamediv>
    <refsynopsisdiv>
      <cmdsynopsis><command>
$DAQBIN/mg_stateedit <replaceable>configuration-file</replaceable>
      </command></cmdsynopsis>
    </refsynopsisdiv>
    <refsect1>
             <title>DESCRIPTION</title>
          <para>
            <command>mg_stateedit</command> provides a graphical editor for the
            DAQ manager state machine.   When invoking the command a single
            command line parameters is required, the path of the configuration
            database file.
          </para>
          <para>
             A state machine consists of a set of
            defined states and their legal successor states.
            The process of the state machine changing state from
            one state to another is called a <firstterm>transition</firstterm>.
            In the DAQ manager, these transitions can trigger the execution of
            sequences, which must succeed for the transition to succeed.
            
          </para>
          <para>
            Before describing the interface, some terminology.  The states
            the state machine can transition to from any givnen state
            are called <firstterm>Successor States</firstterm>.  The states
            from which a state can transition to are called
            <firstterm>Precursor States</firstterm>.
            The process of defining a state machine is that of defining the
            states and, for each state defining its successor states.  In some
            cases, it's also convenient to define a state's precursor states.
            The <command>mg_stateedit</command> command allows for both.
          </para>
          <para>
            The window resented by <command>mg_stateedit</command> is primarily
            composed of three list boxes.  The center list box lists the defined
            states selecting (single clicking) a state in the States list box
            populates the left listbox with that state's precursor states and
            the right list box with that state's successor states.
          </para>
          <para>
            Below each list box is a <guibutton>-</guibutton> button. Clicking that
            button when a state is selected in any list box removes that state
            from that listbox:
          </para>
          <itemizedlist>
            <listitem>
               <para>
                  Clicking that button below the middle listbox removes that state's
                  definitions (cleaning up all transitions to that state from
                  precursor states and all transitions to successor states as well).
               </para>
            </listitem>
            <listitem>
               <para>
                  Clicking that button below the left listbox removes that state
                  from the precursor states of the selected state in the middle
                  listbox. This removes the allowed transition from the precursor
                  state to the selected state.
               </para>
            </listitem>
            <listitem>
               <para>
                  Similarly, clicking that button below the right list box removes
                  that state from the successor states of the selected state in
                  the middle listbox.  This removes the allowed transition from
                  the selected state to that successor state.
               </para>
            </listitem>
          </itemizedlist>
          <para>
            Below the <guibutton>-</guibutton> buttons below each listbox are
            text entry widgets and a <guibutton>+</guibutton> button.
          </para>
          <itemizedlist>
            <listitem>
               <para>
                  To add a new state, type a unique state name  in the middle
                  entry and click its <guibutton>+</guibutton> button.
               </para>
            </listitem>
            <listitem>
               <para>
                  To add a new precursor state  to the selected state,
                  type the name of an existing state in the left listbox and
                  click its <guibutton>+</guibutton> button.  The state
                  must be defined or an error will be displayed.
               </para>
            </listitem>
            <listitem>
               <para>
                  To add a new successor state to the selected state,
                  type the name of an existing state in the right listbox
                  and click its <guibutton>+</guibutton> button.  Once more the
                  state must already be defined or an error will be displayed.
               </para>
            </listitem>
          </itemizedlist>
          <para>
            Note that all changes change the underlying database immediately.
          </para>
    </refsect1>
</refentry>

<refentry id='daq1.mg_seqedit'>
   <refmeta>
      <refentrytitle id='daq1.mg_seqedit.title'>mg_seqedit</refentrytitle>
      <manvolnum>1daq</manvolnum>
   </refmeta>
   <refnamediv>
      <refname>mg_seqedit</refname>
      <refpurpose>Edit DAQ manager sequences</refpurpose>
    </refnamediv>
    <refsynopsisdiv>
      <cmdsynopsis><command>
$DAQBIN/mg_seqedit <replaceable>configuration-file</replaceable>
      </command></cmdsynopsis>
    </refsynopsisdiv>
    <refsect1>
             <title>DESCRIPTION</title>
          <para>  
            The command <command>mg_seqedit</command> allows you to define
            and edit sequences of program executions that are run by
            the manager during state transitions.  Sequences are composed of
            steps.  Each step results in running a defined program.  Transitory
            programs are run synchronously while other program types are run
            in the background.
          </para>
          <para>
            Sequences are bound to or <firstterm>triggered by</firstterm> states.
            When a transition is performed into
            a state, the sequences triggered by those states are run.  The
            sequences are run one at a time in the order in which they were defined.
          </para>
          <para>
            The GUI for <command>mg_seqedit</command> consists of a listbox
            that displays the sequences that have been defined.  An entry and
            drop down list provide the ability to define new sequences.
            
          </para>
          <para>
            To create a new sequence, ype in a new unique sequence name in the
            text entry box, and select its trigger state
            from the drop down. Clicking <guibutton>Add</guibutton> adds the
            new sequence to the list of defined sequences.
          </para>
          <para>
            Sequences are edited by double-clicking them in the listbox.  This
            is also how a new sequence is assigned steps.  Double clicking
            a sequence pops up the sequence step editor window.
          </para>
          <para>
            Each step has a step number, which determines its order in the sequence.
            The step numbers are floating point numbers ensuring new steps can
            always be inserted between existing steps. Steps also have a program
            that is run and optional delays before and after the step
          </para>
          <para>
            To add a new step, select the program from the pulldown menu
            near the bottom of the window, optionally set non zero pre and post
            delay values and click <guibutton>Add</guibutton>  by default
            new steps are added at the end.  If a step is selected (single click it),
            when a new step is added, the step is inserteed above that step.
          </para>
          <para>
            A context menu is brought up by right clicking any step.  The menu
            allows yout to delete the step, move it up in the order or move it
            down. 
          </para>
          <para>
            At the very bottom of the page are three action buttons:
          </para>
          <variablelist>
            <varlistentry>
               <term><guibutton>Save</guibutton></term>
               <listitem>
                   <para>
                    Saves the updated (or new) sequence steps.
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term><guibutton>Delete...</guibutton></term>
               <listitem>
                   <para>
                    Prompts for confirmation and then deletes the sequence
                    if you confirm.
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term><guibutton>Cancel</guibutton></term>
               <listitem>
                   <para>
                    Makes no changes.  The existing sequence is unmodified and
                    the new sequence is not saved.
                   </para>
                </listitem>
            </varlistentry>
          </variablelist>
    </refsect1>
</refentry>
 
<refentry id='daq1.mg_cfgevlog'>
   <refmeta>
      <refentrytitle id='daq1.mg_cfgevlog.title'>mg_cfgEvlog</refentrytitle>
      <manvolnum>1daq</manvolnum>
   </refmeta>
   <refnamediv>
      <refname>mg_cfgEvlog</refname>
      <refpurpose>Configure DAQ manager event logging.</refpurpose>
    </refnamediv>
    <refsynopsisdiv>
      <cmdsynopsis><command>
$DAQBIN/mg_cfgEvlog <replaceable>configuration-file</replaceable>
      </command></cmdsynopsis>
    </refsynopsisdiv>
    <refsect1>
             <title>DESCRIPTION</title>
          <para>
            The <command>mg_cfgEvlog</command> command provides a utility that
            supports configuring the event loggers defined in a
            DAQ manager configuration database.  
          </para>
          <para>
            Before we begin describing how to use <command>mg_cfgEvlog</command>,
            It's important to define some terms:
          </para>
          <glosslist>
            <glossentry>
              <glossterm>Enabled Logger</glossterm>
              <glossdef><para>
                An enabled logger will log data to its destination if logging is
                globally enabled in the logger.
              </para></glossdef>
            </glossentry>
            <glossentry>
              <glossterm>Critical Logger</glossterm>
              <glossdef><para>
                A critical logger is one who's failure will shutdown the data
                acquisition system.
              </para></glossdef>
            </glossentry>
            <glossentry>
              <glossterm>Partial Logger</glossterm>
              <glossdef><para>
                Partial loggers do no directory management and, therefore,
                simplly log timestamped run files in the destination directory.
                These operate identicall to loggers run in the
                ReadoutGUI multilogger package.
              </para></glossdef>
            </glossentry>
            <glossentry>
              <glossterm>Full Logger</glossterm>
              <glossdef><para>
                These are loggers that are not partial loggers.  See
                <literal>COMPLETE LOGGERS</literal> below for more information.
              </para></glossdef>
            </glossentry>
          </glosslist>
          <para>
            The event log editor GUI consists of a table of current event
            log definitions, a definition section below the table and two
            action buttons <guibutton>Save</guibutton> and <guibutton>Cancel</guibutton>
            Changes are not immediately saved to the database.  WHen you are
            satisfied with the definitions you see in the eventlog list,
            click <guibutton>Save</guibutton> to save those definitions oe
            <guibutton>Cancel</guibutton> if you don't want this work saved.
            <guibutton>Cancdel</guibutton> will simply reload the table with the
            event log definitions in the database.
          </para>
          <para>
            Items in the list of loggers have a context menu that can be posted by
            right clicking them.
            The context menu has the following commands:
          </para>
          <variablelist>
            <varlistentry>
               <term><literal>New</literal></term>
               <listitem>
                   <para>
                    Resets the event log editor form to its defaults.  The
                    action button in the form will be labeled <guibutton>Create</guibutton>
                    indicating that clicking it creates a new event logger definition.
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term><literal>Edit</literal></term>
               <listitem>
                   <para>
                    Loads the definition into the definition form and relabels its
                    action button <guibutton>Modify</guibutton> indiciating that
                    clicking it will modify the definition being edited.
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term><literal>Delete</literal></term>
               <listitem>
                   <para>
                    Deletes the definition under the pointer.
                   </para>
                </listitem>
            </varlistentry>
          </variablelist>
          <para>
            The Eventlog editor form contains the following elements:
          </para>
          <variablelist>
            <varlistentry>
               <term><literal>DAQRoot</literal></term>
               <listitem>
                   <para>
                    The NSCLDAQ installation directory root. This is loaded with the
                    directory root for the DAQ version from which the editor
                    was run.  It can be edited if there are special needs but,
                    in general, should not be earlier than 12.0-pre3.
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term><literal>Source</literal></term>
               <listitem>
                   <para>
                    Should be edited to be the URI of the ring buffer that will
                    be logged to disk.
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term><literal>Dest.</literal></term>
               <listitem>
                   <para>
                    Should be edited or browsed to the directory in which
                    data will be logged.  For partial loggers all data will
                    be logged into this directory.  For Complete loggers,
                    this is the top level of the directory tree maintained by
                    the logger.  See <literal>COMPLETE LOGGERS</literal>.
                   </para>
                   <para>
                    Note that if the event logger is containerized, this path must
                    be a valid path within the active container.
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term><literal>Host:</literal></term>
               <listitem>
                   <para>
                    Should be edited to the DNS name of the computer in which the
                    event logger will run.
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term><literal>Container</literal></term>
               <listitem>
                   <para>
                    Pulldown menu that allows you to select a container in which
                    the event logger runs.  Note that if this is empty, the logger
                    will run native.
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term><literal>Partial</literal></term>
               <listitem>
                   <para>
                    If checked, the logger will be a partial logger otherwise
                    it will be complete.
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term><literal>Critical</literal></term>
               <listitem>
                   <para>
                    If checked the logger is a critical component of the DAQ system
                    and unexpected exits will <literal>SHUTDOWN</literal> the
                    intire system.
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term><literal>Enabled</literal></term>
               <listitem>
                   <para>
                    If checked the logger is enabled.  If not it will not record
                    data even if the global recording is enabled.
                   </para>
                </listitem>
            </varlistentry>
          </variablelist>
          <para>
            Finally the edit form has an action button that is labeled
            <guibutton>Modify</guibutton> if clicking it will replace the definition
            that you initially loaded into the form using the <literal>Edit</literal>
             context menu or <guibutton>Create</guibutton> if it will create a
             new definition.
          </para>
    </refsect1>
    <refsect1>
      <title>COMPLETE LOGGERS</title>
      <para>
        A complete logger produces the same directory tree as the ReadoutGui's
        primary event log.  The destination specified for the logger is the
        top of a directory tree that looks like this:
      </para>
      <informalfigure>
        <programlisting>
destination +
            +----> experiment+
            |                +---> current
            |                +---> run1
            |                +---> run2
          ...             ...
            +----> complete
    
        </programlisting>
      </informalfigure>
      <para>
        The experiment subdirectory has run subdirectories for each recorded run
        and one for the run currently being recorded.  While event recording is
        in progress, the current subdirectory has links to the event file segments
        in the associated run.
      </para>
      <para>
        When event recording for a run is complete, several actions are taken:
      </para>
      <itemizedlist>
        <listitem>
           <para>
              The link(s) to the event file(s) are moved to the complete
              directory.
           </para>
        </listitem>
        <listitem>
           <para>
              All other files inthe current directory are copied into the
              run directory recursively.  Furthermore, links are derefrenced rather than
              copied.
           </para>
        </listitem>
        <listitem>
           <para>
              Permissions are set on the run directory and its contents to
              ensure that accidental deletion of the files it contains are
              harder.
           </para>
        </listitem>
      </itemizedlist>
      <para>
        The way to think of all of this is that the complete directory
        offers a view of the entire experiment.  All event files are accessible
        by following the links in that directory.
      </para>
      <para>
        The experiment/current directory provides a view of the run in progress.
        Its links and metadata describe the run in progress and data taken for it.
      </para>
      <para>
        The experiment/run* directories provide per run views where each event file
        is packaged with metadata associated with that run.
      </para>
    </refsect1>
    
</refentry>


<refentry id='daq1.mg_kvedit'>
   <refmeta>
      <refentrytitle id='daq1.mg_kvedit.title'>mg_kvedit</refentrytitle>
      <manvolnum>1daq</manvolnum>
   </refmeta>
   <refnamediv>
      <refname>mg_kvedit</refname>
      <refpurpose>Edit the DAQ Manager Key/Value Store</refpurpose>
    </refnamediv>
    <refsynopsisdiv>
      <cmdsynopsis><command>
$DAQBIN/mg_kvedit <replaceable>configuration-file</replaceable>
      </command></cmdsynopsis>
    </refsynopsisdiv>
    <refsect1>
             <title>DESCRIPTION</title>
          <para>
            <command>mg_kvedit</command> provies a graphical editor for
            the contents of the key value store.  In the command invokation,
            <replaceable>configuration-file</replaceable> is the manager
            database configuration file.  
          </para>
          <para>
            The key value store associates arbitrary keys with arbitrary values.
            It can be used by applications to store metadata required by their
            applications.  It is also used by standard components of the
            managed DAQ system.  These components define the following keys:
          </para>
          <variablelist>
          <varlistentry>
             <term><literal>title</literal></term>
             <listitem>
                 <para>
                  This is used to set run titles in compatible
                  Readout programs.  It contains the desired title for the
                  next run.
               </para>
            </listitem>
          </varlistentry>
          <varlistentry>
             <term><literal>run</literal></term>
             <listitem>
                 <para>
                  Is used to set the run number in compatible Readout programs.
                  It contains the desired run number for the next run.
               </para>
            </listitem>
          </varlistentry>
        </variablelist>
        <para>
          The editor provides a window that, at the top, contains a table
          of key/value pairs.  At the bottom is an editing region that provides
          entries for a key and a value. Selecting (by clicking) a key value
          pair in the table loads the key and its value into the editor fields where
          either or both may be modified.  
        </para>
        <para>
          Clicking the <guibutton>Update</guibutton> button updates the table.
          If the key is an existing  key its value will be modified.  If it is
          a new key, a new key/value pair will be created. 
        </para>
        <para>
          Clicking on the <guibutton>Delete</guibutton> button removes a key
          and its value from the table.
        </para>
        <para>
          Note that none of the edits described above affect the database.
          The <guibutton>Save</guibutton> button writes all changes to the
          database key value table.
        </para>
    </refsect1>
</refentry>

<refentry id='daq1.mg_authedit'>
   <refmeta>
      <refentrytitle id='daq1.mg_authedit.title'>mg_authedit</refentrytitle>
      <manvolnum>1daq</manvolnum>
   </refmeta>
   <refnamediv>
      <refname>mg_authedit</refname>
      <refpurpose>Edit NSCLDAQ manager authorization database.</refpurpose>
    </refnamediv>
    <refsynopsisdiv>
      <cmdsynopsis><command>
$DAQBIN/mg_authedit <replaceable>configuration-file</replaceable>
      </command></cmdsynopsis>
    </refsynopsisdiv>
    <refsect1>
             <title>DESCRIPTION</title>
          <para>
            The <command>mg_authedit</command> command allows you to edit the
            authorization configuration of the experiment.  Auhorization provide
            access to functionality of the NSCLDAQ manager to specific users
            (login usernames).  Note that in NSCLDAQ 12.0, authorization is not
            enforced.  We anticipate that in the future as we come to understand
            the roles in an experiment better, we can layer these protections into
            the manager.
          </para>
          <para>
            The user interface of <command>mg_authedit</command> consists of
            the following sections:
          </para>
          <itemizedlist>
            <listitem>
               <para>
                  At the top is a tree view.  The top level items are users
                  that have been defined to the expermiment.  Second level
                  items (accessed by left clicking on the wedge icon to the left
                  of a user's name) are the roles held by that user.
               </para>
            </listitem>
            <listitem>
               <para>
                  Below the treeview is a section that allows you to add new users.
                  This is a frame with the lable <literal>Add user</literal>
               </para>
            </listitem>
            <listitem>
               <para>
                  Below the <literal>Add user</literal>  frame is a frame of
                  widgets that allows you to add and delete roles.  This frame
                  is labelled <literal>Add role</literal>.
               </para>
            </listitem>
            <listitem>
               <para>
                  At the bottom  of the user interface is a button labeled
                  <guibutton>Save</guibutton>.   All changes to the users and
                  roles and the roles granted to specific users are held within
                  the user interface until the <guibutton>Save</guibutton> button
                  is clicked.  
               </para>
               <para>
                To exit without saving updated roles and users, simply
                delete the window (on most window managers this means clicking)
                an <literal>X</literal> at the right top of the window banner.
               </para>
            </listitem>
          </itemizedlist>
          <para>
            The treeview supports context menus both on user and roles they've
            been granted.
            Right clicking on a user brings up a context menu with the
            following commands:
          </para>
          <variablelist>
            <varlistentry>
               <term><guimenuitem>Remove user...</guimenuitem></term>
               <listitem>
                   <para>
                    Prompts for confirmation and, if given, removes the user
                    and, of course.  This operation cleans up  properly, that is
                    first the user's roles are revoked and then the user
                    him/herself is removed from the list of authorized users.
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term><guimenuitem>Grant Roles...</guimenuitem></term>
               <listitem>
                   <para>
                    Pops up a list box populated with all of the roles the
                    user does <emphasis>not</emphasis> have.  The list box
                    supports multiple selection.  Select the rols you want to
                    grant and click the <guibutton>Ok</guibutton> button.
                    The <guibutton>Cancel</guibutton> button makes no changes
                    to the granted roles.
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term><guimenuitem>Revoke role(s)...</guimenuitem></term>
               <listitem>
                   <para>
                    Pops up a list box populated with the roles that have been
                    granted to the user.  Multiple selections are allowed.
                    Select the role(s) you wish to revoke from the user and
                    click <guibutton>Ok</guibutton> to revoke them.  The
                    <guibutton>Cancel</guibutton> button makes no changes
                    to the granted roles.
                   </para>
                </listitem>
            </varlistentry>
            
          </variablelist>
          <para>
            The context menu for a role can be accessed by right clicking on the
            role.  It contains the following menu commands.
          </para>
          <variablelist>
            <varlistentry>
               <term><guimenuitem>Revoke</guimenuitem></term>
               <listitem>
                   <para>
                    Revokes that role, and that role only, from the associated
                    user.
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term><guimenuitem>Grant role(s)...</guimenuitem></term>
               <listitem>
                   <para>
                    As with the user context menu, allows you to grant additional
                    roles to the user that holds this role.
                   </para>
                </listitem>
            </varlistentry>
          </variablelist>
          <para>
            The <literal>Add user</literal> frame allows you to add users to the
            list of authorized users. Simply type the username of the new
            authorized user and click the <guibutton>Add</guibutton> button
            to the right of the text entry.  If the user you type in is already
            in the authorized list, an error dialog will pop up to inform you
            of that.
          </para>
          <para>
            The <literal>Add role</literal> frame allows you to add and delete
            roles.  To add a role, simply type the new role name and click the
            <guibutton>add</guibutton> button. As with adding users,
            an error message will pop up if you type in an existing role name.
            
          </para>
          <para>
            To delete a role, simply click the <guibutton>Delete...</guibutton>
            button.  A list box will pop up populated with the names of all of the
            roles that have been defined.   Select thew role(s) to remove and click
            <guibutton>Ok</guibutton> to remove them.  Roles will be revoked from
            all that hold them before being deleted so no dangling role references
            will remain.  Clicking the <guibutton>Cancel</guibutton> button
            makes no changes.
          </para>
    </refsect1>
</refentry>

<refentry id='daq1.mg_monitorOutput'>
   <refmeta>
      <refentrytitle id='daq1.mg_monitorOutput.title'>mg_monitorOutput</refentrytitle>
      <manvolnum>1daq</manvolnum>
   </refmeta>
   <refnamediv>
      <refname>mg_monitorOutput</refname>
      <refpurpose>Monitor the Output from Managed Programs.</refpurpose>
    </refnamediv>
    <refsynopsisdiv>
      <cmdsynopsis>
        <command>
$DAQBIN/mg_monitorOutput <replaceable>host user</replaceable>
        </command>
      </cmdsynopsis>
    </refsynopsisdiv>
    <refsect1>
             <title>DESCRIPTION</title>
          <para>
            The <command>mg_monitorOutput</command> program provides a display
            of the output that comes from programs run under that DAQ manager.
            THe parameters <replaceable>host</replaceable> and
            <replaceable>user</replaceable> are, respectively, the host on
            which the manager is running and the user that started the manager.
            These two parameters allow the program to locate the service advertised
            by the manager.
          </para>
          <para>
            If the manager exits, or otherwise drops its connection to
            <command>mg_monitorOutput</command>, the program attempts to retry
            for some period of time and, if not successful, allows the user
            to retry once they are sure the manager is up and running or to exit
            if they are certain it won't be up in a reasonable time.
          </para>
          <para>
            The user interface consists of a menubar with a
            <guimenu>Settings</guimenu> menu. Below the menubar is a large
            text widget with a vertical scroll bar.  Output are appended to the
            end of the text in this text widget, as they are received from the
            manager.  A limited history of output is maintained and the scrollbar
            can be used to examine older output.  Below the output display
            is a status line that indicates whether or not the program is
            connected to the manager.
          </para>
          <para>
            The <guimenu>Settings</guimenu> menu provides commands that
            allow you to modify the settings of the output menu as well
            as the connection retry settings.  Let's look at the menu
            choices in this menu.
          </para>
          <variablelist>
            <varlistentry>
               <term><menuchoice><guimenu>Settings</guimenu><guimenuitem>OutputSettings...</guimenuitem></menuchoice></term>
               <listitem>
                   <para>
                    Provides a dialog that allows you to set the characterisics
                    of the output window.  The dialog provides a spinbox
                    that allows you to set the number of lines that are retained.
                    The checkbox labeled <literal>Show debugging otuput</literal>
                    is not used and is ignored a this time.
                   </para>
                   <para>
                    Set the history to the desired number of lines and then click
                    <guibutton>Ok</guibutton> to make the change or
                    <guibutton>Cancel</guibutton> to remove the dialog\
                    without making any changes.
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term><menuchoice><guimenu>Settings</guimenu><guimenuitem>Connection Settings...</guimenuitem></menuchoice></term>
               <listitem>
                   <para>
                    This brings up a dialog that describes what the program will
                    do when it loses connection with the manager.
                    If the connection is lost the program will attempt to
                    restablish its connection for a specified number of
                    <firstterm>retries</firstterm> at a specified
                    <firstterm>retry interval</firstterm>.
                    Once the retry count is exceeded, the program will prompt
                    for what to do next.
                   </para>
                   <para>
                    The menu selection pops up a dialog that allows you to
                    set both of these parameters.
                    The <literal>Retries before giving up</literal> spin box
                    sets the number of retries.  The
                    <literal>Time in secs between retries</literal> spin box
                    allows you to set the retry  interval  in seconds.
                   </para>
                   <para>
                    To accept the new paramters click <guibutton>OK</guibutton>
                    to reject them, click <guibutton>Cancel</guibutton>.
                   </para>
                </listitem>
            </varlistentry>
          </variablelist>
          
    </refsect1>
</refentry>

<refentry id='daq1.rdo_RunControl'>
   <refmeta>
      <refentrytitle id='daq1.rdo_RunControl.title'>rdo_RunControl</refentrytitle>
      <manvolnum>1daq</manvolnum>
   </refmeta>
   <refnamediv>
      <refname>rdo_RunControl</refname>
      <refpurpose>DAQ Manager Run Control Panel.</refpurpose>
    </refnamediv>
    <refsynopsisdiv>
      <cmdsynopsis><command>
$DAQBIN/rdo_RunControl <replaceable>host user readout-program-name...</replaceable>
      </command></cmdsynopsis>
    </refsynopsisdiv>
    <refsect1>
             <title>DESCRIPTION</title>
          <para>
            Provides a DAQ Manager run control panel.  The program parameter,
            <replaceable>host</replaceable> is the host in which the DAQ manager
            is running.  <replaceable>user</replaceable> is the user name
            of the user that started the manager.  In addition to these, a
            sequence of
            <replaceable>readout-program-name</replaceable> parameters must
            be provided which are the names of the programs that are readouts
            which implement the ReadoutREST protocol.  If there are non
            standard (e.g. Non NSCLDAQ) Readout programs which don't have
            a ReadoutREST controlling front end, these should be omitted
            from the list.
          </para>
          <para>
            The user interface is divided into roughly three sections.
            The top section provides the capability to monitor and modify run
            metadata.  This metadata inlcudes the current and next title as well
            as the current and next run.
          </para>
          <para>
            The middle section provides controls and status information
            to control state transitions in the manager and to monitor
            the aggregate state of the Readout programs.  This consists of
            three blocks of controls.  The left block supports booting and
            shutting down the experiment as well as monitoring the manager state.
          </para>
          <para>
            All state information is polled from the appropriate data source,
            therefore, if more than one control panel is run, all will show
            consistent state information regardless of which of thos panels
            changed system state.  For example if the user running one control panel
            changes the title, all other control panels will reflect that change
            after their next poll for status.  Status polling is approximately once
            per second.
          </para>
          <para>
            The middle block provides run control when the system is booted.
            It  always allows the system to be shutdown.  If the system can
            start a run a <guibutton>Begin</guibutton> button is present to do that.
            If the system is actively taking data an <guibutton>End</guibutton>
            button allows data taking to be halted.  A booted/idle system
            can also request that readout programs, that support this,
            re-initialize their hardware via the <guibutton>Initialize</guibutton>
            button.
          </para>
          <para>
            The <literal>State</literal> shown in this section is an aggregate
            state from all specified readouts.  If all Readouts report the same
            state, this state is reflected here.  If Readouts show differing states,
            the text <literal>inconsistent</literal> is displayed.  This can
            happen normally during state transitions as the Readouts asynchronously
            change state.
          </para>
          <para>
            Finally at the right hand side of the run controls section a
            checkbox labeled <literal>Recording</literal>, when checked informs
            the manager that eventloggers should be started when the run starts,
            recording data for that run.
          </para>
          <para>
            The bottom section of the user interface show the status of all of the
            readout programs described on the command line.  Note that if you miss
            one, it will still participate in run transitions if sequences are
            appropriately defined, as it is the sequences executed by the manager
            that are actually responsible for starting data taking in readout programs.
          </para>
          <para>
            The bottom section is a tabbed notebook. A single tab labeled
            <literal>summary</literal> provides a table of all of the readout
            programs specified on the command line.  Columns of the table provide
            the name of the program, the host  in which it runs, whether or not
            the program is responding to REST requests and the whether or not
            the manager thinks the program is running.
          </para>
          <para>
            Once the Readout programs start and become responsive to REST requests
            for the first time, additional tabs are created for them.  Each additional
            tab provides trigger statistics for one of the Readout programs.  The
            labels on these tabs will be of the form <replaceable>name@host</replaceable>
            where <replaceable>name</replaceable> is the program name and
            <replaceable>host</replaceable> is the host in which it runs.
          </para>
          <para>
            The statistics tabs will dynamically show the number of triggers,
            accepted triggers, and approximate bytes of data generated (event body
            sizes).  Both cumulative statistics (across all runs), and Statistics
            for the current run will be shown.  These statistics will update
            approximately every second.
          </para>
    </refsect1>
</refentry>

<refentry id='daq1.evbmonitor'>
   <refmeta>
      <refentrytitle id='daq1.evbmonitor.title'>EVBMonitor</refentrytitle>
      <manvolnum>1daq</manvolnum>
   </refmeta>
   <refnamediv>
      <refname>EVBMonitor</refname>
      <refpurpose>Monitor Event Builder Statistics via REST Interface.</refpurpose>
    </refnamediv>
    <refsynopsisdiv>
      <cmdsynopsis><command>
$DAQBIN/EVBMonitor <replaceable>host user <optional>service</optional></replaceable>
      </command></cmdsynopsis>
    </refsynopsisdiv>
    <refsect1>
             <title>DESCRIPTION</title>
          <para>
            The <command>EVBMonitor</command> command provides statistics monitoring
            for an event builder when it's run with its REST interface plugin
            enabled.  This is normally the case when an event builder is run under
            the control of the DAQ manager subsystem.  When this is true, the
            event builder does not have access to a controlling desktop and
            therefore cannot display its normal statistics user interface.
          </para>
          <para>
            The command line parameter <replaceable>host</replaceable>
            is the system in which <emphasis>the event builder is running</emphasis>.
            Depending on the programs that encapsulate the event builder in the
            manager's sequences, this may not be the same as the host in which
            the manager itself runs.  <replaceable>user</replaceable> is the
            user running the manager as all programs run by the manager will be
             run under that user's account.  Finally the optional
             <replaceable>service</replaceable> parameter provides the service
             name of the REST interface advertised by the event builder if it is
             not the default service (<literal>ORDERER_REST</literal>).  This
             may be needed if there are several event builders and more than one of
             them runs in a single host.
          </para>
          <para>
            Let's look at the user interface provided by the event builder monitor.
            The UI is divided into roughly three sections.  The top section is
            a tabbed notebook.  Each tab selects a different set of statistics
            exported by the event builder (more properly the orderer).
            The bottom left is a table listing the connected data sources.
            To the right of that is a status block.
          </para>
          <para>
            The tabbed notebook has the following tabs:
          </para>
          <variablelist>
            <varlistentry>
               <term><literal>Input Stats</literal></term>
               <listitem>
                   <para>
                    This page shows the input statistics of the event builder
                    and contains three counters.  The oldest timestamp
                    queued at any time.  The newest timestamp seen and the
                    number of queued fragments.  Note that when the number
                    of queued fragments drops to zero, the system does not
                    clear the Oldest timestamp counter.
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term><literal>Queue Stats</literal></term>
               <listitem>
                   <para>
                    Provides a table of the queue statistics.  Each line
                    represents the statistics of a single input queue.
                    The <literal>Id</literal> of the queue is the source id
                    associated with the event fragments that will be routed
                    to that queue.  
                   </para>
                   <para>
                    The <literal>Depth</literal>, <literal>Oldest</literal>
                    and <literal>Bytes</literal> are respectively, the number
                    of fragments queued in that queue, the timestamp of the
                    oldest fragment in the queue (fragment at the front of the
                    queue), and the number of bytes in the queue.
                   </para>
                   <para>
                    Finally the <literal>Dequeued</literal> and <literal>Queued</literal>
                    columns are the number of data bytes that have been dequeued
                    from the queue and queued to the queue respectively.  If the
                    depth is <literal>0</literal>, these two items should be equal.
                    In no case should <literal>Dequeued</literal> be greater than
                    <literal>Queued</literal>.
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term><literal>Barrier Stats</literal></term>
               <listitem>
                   <para>
                    This tab shows the top level barrier statistics.  Ideally,
                    when used with NSCLDAQ, all barriers will be complete and
                    homogeneous.  The complete barrier statistics are the first
                    row and contain, from left to right, the number of compete
                    barriers, the number of homogeneous barriers and the
                    number of heterogeneous barriers.  A heterogeneous barrier
                    is one where all queues received a barrier fragment within
                    the required barrier timeout, but there was more than one
                    barrier type.  
                   </para>
                   <para>
                    The second line provides the same information but for incomplete barriers.
                    An incomplete barrier is one where not all queues received
                    barrier fragments within the barrier timeout from the first
                    barrier received.
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term><literal>Complete Barriers</literal></term>
               <listitem>
                   <para>
                    Drills down into more details about the complete barriers
                    seen.  Note that a complete barrier <emphasis>could</emphasis>
                    be heterogenous.  The statistics in this page help to
                    untangle that case.
                   </para>
                   <para>
                    The display is a tree view.  There are two top level
                    elements of the tree; <literal>By Type</literal> that,
                    when expanded shows the number of each type of barrier
                    fragment that participated in a complete barrier, and
                    <literal>By Source</literal> which provides information
                    about the barriers received from each source.
                   </para>
                   <para>
                    The <literal>By Source</literal> top level, when expanded,
                    has another level for each data source id. When expanded,
                    that provides a list of the number of barriers of each
                    type that were contributed to complete barriers from that
                    source.
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term><literal>Incomplete Barriers</literal></term>
               <listitem>
                   <para>
                    This tab provides information about barriers that were
                    incomplete.  A barrier synchronization is incomplete if barrier
                    fragments were not received on all queues within the barrier
                    timeout of the first barrier fragment making its way to the
                    front of a queue.
                   </para>
                   <para>
                    This page is a tree view with two top levels.
                    The <literal>By # Missing</literal> when expanded,
                    shows the a count of the number of times a specific number
                    of fragments is missing.  For example, if a single data
                    source did not contribute a barrier once in the only incomplete
                    barrier seen, a subelement labeled <literal>1</literal> (one missing
                    fragment) will be added and the <literal>Count</literal>
                    column for it will display <literal>1</literal> (one time).
                   </para>
                   <para>
                    <literal>By Source id</literal> will have sub-entries for
                    each data source that failed barrier syncrhonization. THe
                    <literal>Count</literal> column will be the number of times
                    that source id did not make the barrier timeout.  In
                    the previous example, suppose the missing data source was
                    id 5.  This event will add a sub-entry labled 5 (the
                    id of the data source that missed the timeout) and
                    with a count of <literal>1</literal> (Missed it once).
                   </para>
                   <para>
                    Note that if a data source is slow getting its barriers in,
                    you'll see pairs of incomplete barriers, one for when all but
                    the slow source was present, and one for when the slow source
                    finally contributed its barrier fragment.
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term><literal>Data Late</literal></term>
               <listitem>
                   <para>
                    Provides the number of data late cases.  This increments
                    every time a fragment arrives but fragments with a later
                    timestamp have already been emitted. This display
                    is a table whose top line is the total number of times this
                    was detected and whose subsequent lines are the number of times
                    this was detected in fragments from specific data sources.  The
                    right most column shows the worst timestamp difference.
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term><literal>Out Of Order</literal></term>
               <listitem>
                   <para>
                    Summarizes the out of order timestamps.  An out of order
                    event is logged when a data source queue emits a fragment that
                    is older than the most recently emitted fragment.  This is
                    often coupled with a data late event.
                   </para>
                   <para>
                    The top row summarizes all data lates over all sources.  The
                    subsequent lines show data sources with non-zero data late
                    events.  The <literal>Count</literal> column is the number
                    of data late events seen. The <literal>Last Good TS</literal>
                    column show the timestamp of the fragment dequeued prior to
                    the one that was out of order and <literal>Offending TS</literal>
                    shows the timestamp from the fragment that was determined
                    to be out of order.
                   </para>
                </listitem>
            </varlistentry>
          </variablelist>
          <para>
            The connection list at the bottom left is a table of the
            connected data sources.  Each line provides the IP address in which the
            source is running, the connection description string of the source,
            the state of the source and the idle status.
          </para>
          <para>
            Finally, the status display shows if the Event builder has
            asserted flow control and if the UI is successfully updating.
            If the Event builder is not responding to update requests,
            a read <literal>Update failed</literal> will be displayed until
            updates work again.  This is normal if, for example, the data acquisition
            system is shutdown.
          </para>
    </refsect1>
</refentry>

<refentry id='daq1.mg_startloggers'>
   <refmeta>
      <refentrytitle id='daq1.mg_startloggers.title'>mg_startloggers</refentrytitle>
      <manvolnum>1daq</manvolnum>
   </refmeta>
   <refnamediv>
      <refname>mg_startloggers</refname>
      <refpurpose>Start Event Managed Event Loggers</refpurpose>
    </refnamediv>
    <refsynopsisdiv>
      <cmdsynopsis><command>
$DAQBIN/mg_startloggers <replaceable>manger-host manager-user</replaceable>
      </command></cmdsynopsis>
    </refsynopsisdiv>
    <refsect1>
             <title>DESCRIPTION</title>
          <para>
            Requests that the manager run by the user <replaceable>manager-user</replaceable>
            in the system <replaceable>manager-host</replaceable> start all
            appropriate event loggers.  The manager will only start event loggers
            if the global recording state is on.  Individual loggers will
            only be started if they are enabled.
          </para>
          <para>
            Each started logger will log exactly one run and then exit.
            Therefore loggers should be started early in a
            sequence that is triggered by <literal>BEGIN</literal> transitions.
          </para>
          <para>
            Output from loggers is relayed to the output monitor where
            <link linkend='daq1.mg_monitorOutput' endterm='daq1.mg_monitorOutput.title' />
            will display it if run.
          </para>
    </refsect1>
</refentry>

<refentry id='daq1.rdo_runFromKv'>
   <refmeta>
      <refentrytitle id='daq1.rdo_runFromKv.title'>rdo_runFromKv</refentrytitle>
      <manvolnum>1daq</manvolnum>
   </refmeta>
   <refnamediv>
      <refname>rdo_runFromKv</refname>
      <refpurpose>Set Run Number from Key Value STore</refpurpose>
    </refnamediv>
    <refsynopsisdiv>
      <cmdsynopsis>
        <command>
$DAQBIN/rdo_runFromKv <replaceable>mgr_host mgr_user readout-name</replaceable>
        </command>
      </cmdsynopsis>
    </refsynopsisdiv>
    <refsect1>
             <title>DESCRIPTION</title>
          <para>
            By convention the experiment run number is maintained in the
            value of the
            <literal>run</literal> key of an experiment's key value store.
            This program:
          </para>
          <itemizedlist>
            <listitem>
               <para>
                  Fetches the program definition for the
                  <replaceable>readout-name</replaceable> program from the
                  manager running in <replaceable>mgr_host</replaceable> started by
                  the user <replaceable>mgr_user</replaceable>.  The assumption
                  is that this is a readout program that has the
                  ReadoutREST plugin running.
               </para>
               <para>
                The program definition describes the host in which this
                Readout is running and its username will be the same as
                <replaceable>mgr_user</replaceable>.  The REST service is
                assumed to be running on the default service name.
               </para>
            </listitem>
            <listitem>
               <para>
                  Fetches the value of the <literal>run</literal>  key from
                  the same manager.
               </para>
            </listitem>
            <listitem>
               <para>
                  Requests that the specified Readout program set its run number
                  to the value of the <literal>run</literal> key fetched from
                  the key value store.
               </para>
            </listitem>
          </itemizedlist>
    </refsect1>
    <refsect1>
      <title>TO DO</title>
      <para>
        It is the use of the default REST service name in this and other
        programs that restrict us to a single Readout program per host/user
        pair.  This restriction should be removed at some point by allowing
        users to specify the REST service used by programs and using that
        to select the actual service name.
      </para>
    </refsect1>
</refentry>

<refentry id='daq1.rdo_titleFromKv'>
   <refmeta>
      <refentrytitle id='daq1.rdo_titleFromKv.title'>rdo_titleFromKv</refentrytitle>
      <manvolnum>1daq</manvolnum>
   </refmeta>
   <refnamediv>
      <refname>rdo_titleFromKv</refname>
      <refpurpose>Set Readout Title From the KV 'title' Value.</refpurpose>
    </refnamediv>
    <refsynopsisdiv>
      <cmdsynopsis>
         <command>
$DAQBIN/rdo_titleFromKv <replaceable>mgr_host mgr_user readout_program</replaceable>
         </command>
      </cmdsynopsis>
    </refsynopsisdiv>
    <refsect1>
             <title>DESCRIPTION</title>
          <para>
            By convention the experiment title is maintained in the value of the
            <literal>title</literal> key of an experiment's key value store.
            This program:
          </para>
          <itemizedlist>
            <listitem>
               <para>
                  Fetches the program definition for the
                  <replaceable>readout_program</replaceable> program from the
                  manager running in <replaceable>mgr_host</replaceable> started by
                  the user <replaceable>mgr_user</replaceable>.  The assumption
                  is that this is a readout program that has the
                  ReadoutREST plugin running.
               </para>
               <para>
                The program definition describes the host in which this
                Readout is running and its username will be the same as
                <replaceable>mgr_user</replaceable>.  The REST service is
                assumed to be running on the default service name.
               </para>
            </listitem>
            <listitem>
               <para>
                  Fetches the value of the <literal>title</literal>  key from
                  the same manager.
               </para>
            </listitem>
            <listitem>
               <para>
                  Requests that the specified Readout program set its title
                  to the value of the <literal>title</literal> key fetched from
                  the key value store.
               </para>
            </listitem>
          </itemizedlist>
    </refsect1>
    <refsect1>
      <title>TO DO</title>
      <para>
        It is the use of the default REST service name in this and other
        programs that restrict us to a single Readout program per host/user
        pair.  This restriction should be removed at some point by allowing
        users to specify the REST service used by programs and using that
        to select the actual service name.
      </para>
    </refsect1>
</refentry>
<refentry id='daq1.rdo_control'>
   <refmeta>
      <refentrytitle id='daq1.rdo_control.title'>rdo_control</refentrytitle>
      <manvolnum>1daq</manvolnum>
   </refmeta>
   <refnamediv>
      <refname>rdo_control</refname>
      <refpurpose>Control a Readout via ReadoutREST</refpurpose>
    </refnamediv>
    <refsynopsisdiv>
      <cmdsynopsis>
         <command>
$DAQBIN/rdo_rest <replaceable>rdo_host rdo_user subcommand </replaceable>  <optional><replaceable>parameter...</replaceable></optional>     
         </command>
      </cmdsynopsis>
    </refsynopsisdiv>
    <refsect1>
             <title>DESCRIPTION</title>
          <para>
            Performs an operation defined by <replaceable>subcommand</replaceable>
            on the REST interface of a readout program running in
            <replaceable>rdo_host</replaceable>, run by  <replaceable>rdo_user</replaceable>.
            Note that in general, <replaceable>rdo_user</replaceable> is going to
            be the same as the user that started the DAQ manager if this
            readout program was started by that manager.
          </para>
          <para>
            Some set of subcommands require additional parameters as shown
            in the <literal>SYNOPSIS</literal>.  These parameters will be
            described below.
          </para>
          <para>
            The subcommands currently supported are:
          </para>
          <variablelist>
            <varlistentry>
               <term><literal>begin</literal></term>
               <listitem>
                   <para>
                    Begin data taking.  This requires no additional parameters.
                    Note that for this to succeed, the Readout must be in a state
                    where it's legal to begin a run.
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term><literal>end</literal></term>
               <listitem>
                   <para>
                    Ends data taking.  This requires no additional parameters.
                    For this to succeeed, the Readout must be in a state where
                    it is legal to end a run.
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term><literal>init</literal></term>
               <listitem>
                   <para>
                    Initializes the hardware controlled by the Readout.
                    This requires no additional parameters.
                   </para>
                   <para>
                    Note that some NSCLDAQ Readout programs do not support this.
                    If that is the case, they return a success status from the
                    REST request and just don't act on the request.
                    This operation requires no additional command parameters.
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term><literal>shutdown</literal></term>
               <listitem>
                   <para>
                    Calls on the program to exit.  In practice, Readout should
                    first return a success or failure status before
                    exiting or scheduling an exit for a later time soon in the
                    future. This operation requires no additional command parameters.
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term><literal>incRun</literal></term>
               <listitem>
                   <para>
                    Adds 1 to the current run number.  Note that the run number
                    is only looked at at the beginning of the run.  This operation
                    requires no additional command parameters.
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term><literal>setRun</literal> <replaceable>n</replaceable></term>
               <listitem>
                   <para>
                    Sets the run number to the specified value.  An additional
                    parameter that must be a counting number is required on the command
                    line.  
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term><literal>setTitle</literal> <replaceable>word1...</replaceable></term>
               <listitem>
                   <para>
                    Sets the title to a specific value. The command accepts an
                    arbitrary number of additional command words.  These
                    are space separated and become the title.   Quotation
                    marks can be used to apply additional or different spacing.
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term><literal>getRun</literal></term>
               <listitem>
                   <para>
                    This operation requires no additional command parameters.
                    It outputs the current run number to stdout.
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term><literal>getTitle</literal></term>
               <listitem>
                   <para>
                    This operation requires no additional command parameters.
                    It outputs the current title to stdout.  Note that the
                    result is not quoted.  e.g. <literal>This is a title</literal>
                    rather than <literal>"This is a title"</literal>.
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
               <term><literal>getStatistics</literal></term>
               <listitem>
                   <para>
                    Outputs the Readout's trigger statistics in a human readable
                    table.
                   </para>
                </listitem>
            </varlistentry>
          </variablelist>
    </refsect1>
    <refsect1>
      <title>EXAMPLES</title>
      <example>
        <title>Using rdo_control To Begin A Run</title>
        <programlisting>
<userinput>$DAQBIN/rdo_control localhost fox begin</userinput>
        </programlisting>
      </example>
      <para>
        In this case the Readout program is in the host the user
        <literal>fox</literal> is typing this
        command in.
      </para>
      <example>
        <title>Using rdo_control To Set A Title</title>
        <programlisting>
<userinput>$DAQBIN/rdo_control localhost fox setTitle This is my new title</userinput>
<userinput>$DAQBIN/rdo_control localhost fox setTItle "This title    has   " extra spaces</userinput>
        </programlisting>
      </example>
      <para>
        The example shows that titles with simple spaceing, that won't invoke
        shell substitutions, can just be provided as a bunch of words on the
        command line.   If special spacing is required, or shell substitution
        needs to be ignored,
        one or more title words can be quoted.
      </para>
      <example>
        <title>Using rdo_control To Get Trigger Statistics</title>
        <programlisting>
<userinput>$DAQBIN/rdo_control locahost fox getStatistics</userinput>
<computeroutput>
           Triggers Accepted Triggers Bytes
perRun     0.0      0.0               0.0
cumulative 0.0      0.0               0.0
  
</computeroutput>
        </programlisting>
        <para>
          Note that the trigger statistics are given in a human readable table.
          To get computer readable statistics, a direct REST request can be made
          by your program and the resulting JSON processed.
        </para>
      </example>
    </refsect1>
    <refsect1>
      <title>TO DO</title>
      <para>
        It is the use of the default REST service name in this and other
        programs that restrict us to a single Readout program per host/user
        pair.  This restriction should be removed at some point by allowing
        users to specify the REST service used by programs and using that
        to select the actual service name.
      </para>
      <para>
        It shoulid be possible to also have a utility that accepts as parameters
        the manager host, manager user and Readout program name to specify the
        Readout to use.  This is more consistent with the other
        <command>rdo_*</command> and will work in the event a Readout is migrated
        to a different host due to e.g. hardware failure.
      </para>
    </refsect1>
</refentry>
 
<refentry id='daq1.mgr_startManager'>
   <refmeta>
      <refentrytitle id='daq1.mgr_startManager.title'>mg_startManager</refentrytitle>
      <manvolnum>1daq</manvolnum>
   </refmeta>
   <refnamediv>
      <refname>mg_startManager</refname>
      <refpurpose>Start the DAQ Manager</refpurpose>
    </refnamediv>
    <refsynopsisdiv>
      <cmdsynopsis>
         <command>
$DAQBIN/mg_startManager <replaceable>configuration-database</replaceable>
         </command>
      </cmdsynopsis>
    </refsynopsisdiv>
    <refsect1>
             <title>DESCRIPTION</title>
          <para>
            Starts the experiment manager server with the configuration
            provided in the database whose path is
            <replaceable>configuration-database</replaceable>.  The
            manager will continue to run until explicitly stopped with
            <link linkend='daq1.mg_shutdown' endterm='daq1.mg_shutdown.title'>
              mg_shutdown
            </link>
          </para>
    </refsect1>
</refentry>
 

<refentry id='daq1.mg_shutdown'>
   <refmeta>
      <refentrytitle id='daq1.mg_shutdown.title'>mg_shutdown</refentrytitle>
      <manvolnum>1daq</manvolnum>
   </refmeta>
   <refnamediv>
      <refname>mg_shutdown</refname>
      <refpurpose>Shutdown the DAQ manager.</refpurpose>
    </refnamediv>
    <refsynopsisdiv>
      <cmdsynopsis>
         <command>
$DAQBIN/mg_shutdown <replaceable>host user</replaceable>      
         </command>
      </cmdsynopsis>
    </refsynopsisdiv>
    <refsect1>
             <title>DESCRIPTION</title>
          <para>
            Tries to shut down the DAQ manager that's runing in the system
            <replaceable>host</replaceable> started by <replaceable>user</replaceable>.
            By "tries to shutdown" we mean that the program attempts to ask the
            manager to shutdown via its REST server interface.  As long as that
            interface is working there's a good chance this shutdown will succeed.
          </para>
          <para>
            The shutdown process consists of invoking a
            <literal>SHUTDOWN</literal> transition,
            if the state is not already <literal>SHUTDOWN</literal>.
            Once that transition has completed, the server exits.
          </para>
    </refsect1>
</refentry>

<refentry id='daq1.mg_kvget'>
   <refmeta>
      <refentrytitle id='daq1.mg_kvget.title'>mg_kvget</refentrytitle>
      <manvolnum>1daq</manvolnum>
   </refmeta>
   <refnamediv>
      <refname>mg_kvget</refname>
      <refpurpose>Get the value of a manager KV store key.</refpurpose>
    </refnamediv>
    <refsynopsisdiv>
      <cmdsynopsis>
         <command>
$DAQBIN/mg_kvget <replaceable>host user key</replaceable>
         </command>
      </cmdsynopsis>
    </refsynopsisdiv>
    <refsect1>
             <title>DESCRIPTION</title>
          <para>
            The manager key value store is a set of definable keys and associated
            values.  <command>mg_kvget</command> returns the value of a
            specific key by interacting with a manager server.  Some keys
            (e.g. <literal>title</literal>) have specific meaning.  If it helps
            your experiment, however, you are welcome to define your own keys
            and use either this or the REST API to obtain the values of those
            keys at run-time.
          </para>
          <para>
            The <replaceable>host</replaceable> and <replaceable>user</replaceable>
            parameters select the server by host and the user that started it
            while <replaceable>key</replaceable> selects the key to obtain.
          </para>
          <para>
            On success, the value of the key is output to <literal>stdout</literal>
          </para>
    </refsect1>
    <refsect1>
      <title>EXAMPLES</title>
      <para>
        The exmample below outputs the value of the title key from the server
        running in <literal>daqcompute1</literal> by the user <literal>fox</literal>
        when the value of that key is <literal>Some new title</literal>.
      </para>
      <example>
        <title>Getting the Title Key From the KVSTORE</title>
        <programlisting>
<userinput>$DAQBIN/mg_kvget daqcompute1 fox title</userinput>
<computeroutput>Some new title</computeroutput>
        </programlisting>
      </example>
    </refsect1>
</refentry>
<!-- /manpage -->
