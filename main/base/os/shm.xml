<!-- chapter libraries -->
<chapter>
    <title>Shared memory</title>
    <para>
        The shared memory library, <filename>libshm</filename> provides
        operating system independent access to shared memory objects.
    </para>
    <para>
        This library is available for general use, however it's primary
        use is to improve portability of the RingBuffer software within
        the NSCL DAQ system.
    </para>
    <para>
        To use the software, you must
        <itemizedlist>
            <listitem><para>Incorporate the library header into your source code</para></listitem>
            <listitem><para>Link your program to the library run-time</para></listitem>
        </itemizedlist>
    </para>
    <para>
        Reference information is available in <link linkend='daqshm-manpage'>the reference section</link>
    </para>
    <section>
        <title>Overview of the API, and using it from within your C++ software</title>
        <para>
            The API is implemented as a C++ class named
            <classname>CDaqSHM</classname> with the following static methods:
            <itemizedlist>
                <listitem><para><methodname>create</methodname> creates a new region.</para></listitem>
                <listitem><para><methodname>attach</methodname> attaches to an existing region.</para></listitem>
                <listitem><para><methodname>detach</methodname> Detaches from a shared memory region.</para></listitem>
                <listitem><para><methodname>remove</methodname> destroys and
                existing shared memory </para></listitem>
                <listitem><para><methodname>size</methodname> returns the size
                of a shared memory region in bytes.</para></listitem>
                <listitem><para><methodname>lastError</methodname> retrieves the last error status</para></listitem>
                <listitem><para><methodname>errorMessage</methodname> looks up an error message</para></listitem>
            </itemizedlist>
        </para>
        <para>
            Note that the class is not threadsafe in that the error status information
            is static and therefore shared between all threads without any interlocking.
            
        </para>
        <para>
            The sample program below creates a new shared memory region (if the
            region does not yet exist), obtains a pointer to it, then some time
            later detaches from it.  The create and attach calls also illustrate
            error management.
        </para>
        <example>
            <title>Shared memory library example</title>
            <programlisting>
#include &lt;daqshm.h&gt;                            <co id="shm_includes" />
#include &lt;string&gt;
...

// Create the shared memory region.. report any error except
// that the region already exists:

bool status = CDAQShm::create("mymemory", 0x10000,    <co id="shm_create" />
                            CDAQShm::GroupRead | CDAQShm::GroupWrite |
                            CDAQShm::OtherRead | CDAQShm::OtherWrite);
if (status &amp;&amp; (CDAQShm::lastError() != CDAQShm::Exists)) { <co id="shm_create_fail" />
    std::string exception = "Failed to create new shared memory mymemory: ";
    exception += CDAQShm::errorMessage(CDAQShm::lastError());
    throw exception;
}

// Attach to the region:

void* pMemory = CDAQShm::attach("mymemory");     <co id="shm_attach" />
if (!pMemory) {
    std::string exception = "Failed to attach to shared memory mymemory: ";
    exception            += CDAQShm::errorMesszage(CDAQShm::lastError());
    throw exception;
}

// At this  time pMemory can be used to read/write the shared memory region.

....

if (CDAQShm::detach(pMemory, "mymemory", 0x10000)) {   <co id="shm_detach" />
    std::string exception = "Failed to detach mymemory: ";
    exception += CDAQShm::errorMessage(CDAQShm::lastError());
}


            </programlisting>
        </example>
        <calloutlist>
            <callout arearefs="shm_includes">
                <para>
                    Includes the header for the NSCLDAQ shared memory API.
                    See <link linkend='shm_compile' endterm='shm_compilet' />
                    for information that describes how to ensure this header
                    will be found by the compiler.
                </para>
            </callout>
            <callout arearefs="shm_create">
                <para>
                    Attempts to crate the shared memory. The return value of this
                    method will be
                    <literal>true</literal> on error.  The first parameter is the
                    name of the shared memory regiuon.  The second its size in bytes.
                    The last an or of masks that describe how users other than
                    the creator can access the region.  The owner will always have
                    read/write access.
                </para>
            </callout>
            <callout arearefs="shm_create_fail">
                <para>
                    If the creation failed for any other reason than the region
                    already existing (<literal>CDAQShm::Exists</literal>),
                    an exception of type <classname>std::string</classname> is thrown.
                    The contents of the string provide context for the exception
                    as well as the reason the creation failed.
                </para>
            </callout>
            <callout arearefs="shm_attach">
                <para>
                    Attaches to the shared memory region.  The return value a pointer
                    to the shared memory if successful or a null pointer if not.
                    In this example, once more a string exception describing the
                    failure is constructed and thrown if the <methodname>attach</methodname>
                    failed.
                </para>
                <para>
                    Once the <methodname>attach</methodname> has been done,
                    the shared memory can be accessed through the pointer.
                </para>
            </callout>
            <callout arearefs="shm_detach" >
                <para>
                    Detaches from the memory.  After the
                    <methodname>detach</methodname>, no gaurantees
                    are made about the pointer returned from the
                    <methodname>attach</methodname> call and it therefore
                    should not be dereferences
                </para>
                <para>
                    <literal>true</literal> is returned on error and
                    once more the example code throws a descriptive string
                    exception.
                </para>
            </callout>
        </calloutlist>
    </section>
    <section id='shm_compile'>
        <title id='shm_compilet'>Compiling/Linking your software with the shared memory API</title>
        <para>
            Compiling and linking a program that uses the <classname>CDAQShm</classname>
            class requires that you supply the correct <literal>-I</literal>
            switch so that the header file can be located.  It also
            requires that at link time you supply appropriate
            <literal>-L</literal> and <literal>-l</literal> switches to ensure
            that the library can be located and linked into the executable.
        </para>
        <para>
            We also strongly recommend the use of an <literal>-rpath</literal>
            switch on the link line so that the shared library can be located
            at run-time without further environment variables.
        </para>
        <para>
            The examples below assume that <literal>DAQHOME</literal>
            is an environment variable that points to the top of the
            NSLCDAQ 10.x or later installation tree.
        </para>
        <example>
            <title>Compiling a C++ source that includes <filename>daqshm.h</filename></title>
            <programlisting>
g++ -c  -I$DAQHOME/include mysource.cpp 
            </programlisting>
        </example>
        <example>
            <title>Linking C++ object files that use the
            <filename>daqshm</filename> library</title>
            <programlisting>
g++ -o myprogram obj1.o obj2.o obj3.o -L$DAQHOME/lib -ldaqshm \
    -Wl,"-rpath=$DAQHOME/lib"
            </programlisting>
        </example>
    </section>
</chapter>
<chapter>
    <title>The <classname>Os</classname> class</title>
    <para>
        The <classname>Os</classname> class is a class that contains
        a few static methods that provide abstract interfaces to the underlying
        operating system.
    </para>
    <para>
        To use this class, include the <filename>os.h</filename> header and link
        to <filename>libdaqshm</filename>.
    </para>
    <para>
        See <link linkend='manpage.os' endterm='manpage.os.title' /> for
        reference information that describes this class.
    </para>
</chapter>
<chapter>
    <title>io</title>
    <para>
        The <classname>io</classname> namespace provides functions that read and
        write data.  You might think that reading and writing binary data is
        just a matter of using the <function>read</function>(2) and
        <function>write</function>(2).  There are complications however:
    </para>
    <itemizedlist>
        <listitem>
            <para>
                read/write are allowed to do only partial data transfers.  To
                correctly use them in all circumstances (e.g. on pipes, fifos
                or sockets), you need to loop until either an endfile is seen
                or until the desired number of bytes have been transferred.
            </para>
            <para>
                read/write can be interrupted when the process handles a signal.
                If this happens while the operation is waiting (e.g. read on a blocking
                socket that has no data), the operation returns <literal>-1</literal>
                but the fact that <varname>errno</varname> is <literal>EINTR</literal>
                (or in some circumstances <literal>EAGAIN</literal>) mean that
                the read didn't actually fail but just must be retried.
            </para>
        </listitem>
        <listitem>
            <para>
                Finally if the file descriptor has been set to non blocking
                mode but you really want to get data, you may need to
                loop over successive occurences of return values of
                <literal>-1</literal> and <varname>errno</varname> values of
                <literal>EWOULDBLOCK</literal> (yes you should just set the
                fd to blocking mode but that presupposes that the segment
                of code doing the read/write knows the socket is nonblocking).
            </para>
        </listitem>
    </itemizedlist>
    <para>
        The functions in the <classname>io</classname> namespace
        transparently handle these complications.  Furthermore, in fine
        C++ fashion, actual errors are converted to integer exceptions whose
        value is <varname>errno</varname> at the time the error is detected.
    </para>
    <para>
        To use the I/O namespace functions, include <filename>io.h</filename>
        and link to <filename>libdaqshm</filename>.  Full reference material
        is in
        <link linkend='manpage.io' endterm='manpage.io.title' />.
    </para>
</chapter>
<!-- /chapter -->

<!-- manpage 3daq -->

<refentry id="manpage.io">
  <refentryinfo>
    <author>
        <personname>
            <firstname>Ron</firstname>
            <surname>Fox</surname>
        </personname>
        <personblurb><para></para></personblurb>
    </author>
    <productname>NSCLDAQ</productname>
    <productnumber></productnumber>
  </refentryinfo>
  <refmeta>
     <refentrytitle id='manpage.io.title'>io</refentrytitle>
     <manvolnum>3daq</manvolnum>
         <refmiscinfo class='empty'></refmiscinfo>
  </refmeta>
  <refnamediv>
     <refname>io</refname>
     <refpurpose>Binary I/O operations.</refpurpose>
  </refnamediv>
  
  <refsynopsisdiv>
   <synopsis>
#include &lt;io.h&gt;
       namespace <ooclass><classname>::io</classname></ooclass>
{
    <methodsynopsis>
        <modifier></modifier>
        <type>void </type>
        <methodname>writeData</methodname>
        <methodparam>
            <modifier></modifier><type>int </type>
                <parameter>fd</parameter>
        </methodparam>
        <methodparam>
            <modifier>const </modifier><type>void* </type>
                <parameter>pData</parameter>
        </methodparam>
        <methodparam>
            <modifier></modifier><type>size_t </type>
                <parameter>size</parameter>
        </methodparam>
        <exceptionname>int</exceptionname>
        
    </methodsynopsis>
    <methodsynopsis>
        <modifier></modifier>
        <type>size_t </type>
        <methodname>readData </methodname>
        <methodparam>
            <modifier></modifier><type>int </type>
                <parameter>fd</parameter>
        </methodparam>
        <methodparam>
            <modifier></modifier><type>void* </type>
                <parameter>pBuffer</parameter>
        </methodparam>
        <methodparam>
            <modifier></modifier><type>size_t </type>
                <parameter>nBytes</parameter>
        </methodparam>
        <exceptionname>int</exceptionname>
    </methodsynopsis>  
}
   </synopsis>
  </refsynopsisdiv>
  <refsect1>
     <title>DESCRIPTION</title>
     <para>
        Provides encapsulations of the <literal>read(2)</literal>
        and <literal>write(2)</literal> system calls that transparently handles
        the various edge cases that may cause premature I/O termination.
     </para>
  </refsect1>
  <refsect1>
     <title>
    METHODS
     </title>
     <variablelist>
        <varlistentry>
            <term>
                <methodsynopsis>
                    <modifier></modifier>
                    <type>void </type>
                    <methodname>writeData</methodname>
                    <methodparam>
                        <modifier></modifier><type>int </type>
                            <parameter>fd</parameter>
                    </methodparam>
                    <methodparam>
                        <modifier>const </modifier><type>void* </type>
                            <parameter>pData</parameter>
                    </methodparam>
                    <methodparam>
                        <modifier></modifier><type>size_t </type>
                            <parameter>size</parameter>
                    </methodparam>
                    <exceptionname>int</exceptionname>
                    
                </methodsynopsis>
            </term>
            <listitem>
                <para>
                    Writes <parameter>size</parameter> bytes
                    of data pointed to by <parameter>pData</parameter>
                    to the file descriptor <parameter>fd</parameter>.  When this
                    function returns either all of the bytes have been writtren or
                    an <type>int</type> exception has been thrown whose
                    value is <varname>errno</varname> at the time the
                    exception was thrown.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
                <methodsynopsis>
                    <modifier></modifier>
                    <type>size_t </type>
                    <methodname>readData </methodname>
                    <methodparam>
                        <modifier></modifier><type>int </type>
                            <parameter>fd</parameter>
                    </methodparam>
                    <methodparam>
                        <modifier></modifier><type>void* </type>
                            <parameter>pBuffer</parameter>
                    </methodparam>
                    <methodparam>
                        <modifier></modifier><type>size_t </type>
                            <parameter>nBytes</parameter>
                    </methodparam>
                    <exceptionname>int</exceptionname>
                </methodsynopsis>  
            </term>
            <listitem>
                <para>
                    Reads at most <parameter>nBytes</parameter> of
                    data from the file descriptor <parameter>fd</parameter>
                    into the buffer pointed to by <parameter>pBuffer</parameter>.
                    Returns the number of bytes actually written.
                    When this function returns one of the following is true:
                </para>
                <itemizedlist>
                    <listitem><para>
                        All <parameter>nBytes</parameter> of data have been read.
                    </para></listitem>
                    <listitem><para>
                        The return value is less than <parameter>nBytes</parameter>.
                        This means an end of file condition was encountered when
                        reading the data.  The return value is the nuber of bytes
                        actually transferred.
                    </para></listitem>
                    <listitem><para>
                        The function has thrown an <type>int</type> exception
                        indicating an error of some sort.  The value of the
                        integer thrown is <varname>errno</varname> at the
                        time the error was detected.
                    </para></listitem>
                </itemizedlist>
                            
            </listitem>
        </varlistentry>
                
     </variablelist>
  </refsect1>
</refentry>     

<refentry id="manpage.os">
  <refentryinfo>
    <author>
        <personname>
            <firstname>Ron</firstname>
            <surname>Fox</surname>
        </personname>
        <personblurb><para></para></personblurb>
    </author>
    <productname>NSCLDAQ</productname>
    <productnumber></productnumber>
  </refentryinfo>
  <refmeta>
     <refentrytitle id='manpage.os.title'>Os</refentrytitle>
     <manvolnum>3daq</manvolnum>
         <refmiscinfo class='empty'></refmiscinfo>
  </refmeta>
  <refnamediv>
     <refname>Os</refname>
     <refpurpose>Operating system interfaces.</refpurpose>
  </refnamediv>
  
  <refsynopsisdiv>
   <synopsis>
#include &lt;os.h&gt;
       class <ooclass><classname>Os</classname></ooclass>
{
    <methodsynopsis>
        <modifier>static </modifier>
        <type>std::string </type>
        <methodname>whoami()</methodname>
        <void />
    </methodsynopsis>
    <methodsynopsis>
        <modifier>static </modifier>
        <type>bool </type>
        <methodname>authenticateUser</methodname>
        <methodparam>
            <modifier></modifier><type>std::string </type>
                <parameter>sUser</parameter>
        </methodparam>
        <methodparam>
            <modifier></modifier><type>std::string </type>
                <parameter>sPassword</parameter>
        </methodparam>
    </methodsynopsis>
    <methodsynopsis>
        <modifier>static </modifier>
        <type>int  </type>
        <methodname>usleep</methodname>
        <methodparam>
            <modifier></modifier><type>useconds_t </type>
                <parameter>usec</parameter>
        </methodparam>
    </methodsynopsis>  
    <methodsynopsis>
        <modifier>static </modifier>
        <type>int  </type>
        <methodname>blockSignal</methodname>
        <methodparam>
            <modifier></modifier><type>int </type>
                <parameter>sigNum</parameter>
        </methodparam>
    </methodsynopsis>  
    <methodsynopsis>
        <modifier>static </modifier>
        <type>int  </type>
        <methodname>checkStatus</methodname>
        <methodparam>
            <modifier></modifier><type>int status</type>
                <parameter>, int checkStatus</parameter>
        </methodparam>
        <methodparam>
            <modifier></modifier><type> std::string </type>
                <parameter>msg</parameter>
        </methodparam>
    </methodsynopsis>  
    <methodsynopsis>
        <modifier>static </modifier>
        <type>int  </type>
        <methodname>checkNegativeStatus</methodname>
        <methodparam>
            <modifier></modifier><type>int </type>
                <parameter>returnCode</parameter>
        </methodparam>
    </methodsynopsis>  
  
};
   </synopsis>
  </refsynopsisdiv>
  <refsect1>
     <title>DESCRIPTION</title>
     <para>
        The <classname>Os</classname> class provides a set of static methods
        that abstract some simple operating system interfaces.
     </para>
  </refsect1>
  <refsect1>
     <title>
    METHODS
     </title>
     <variablelist>
        <varlistentry>
            <term>
                <methodsynopsis>
                    <modifier>static </modifier>
                    <type>std::string </type>
                    <methodname>whoami()</methodname>
                    <void />
                </methodsynopsis>
            </term>
            <listitem>
                <para>
                    Returns the name of the user that is currently running
                    the process.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
                <methodsynopsis>
                    <modifier>static </modifier>
                    <type>bool </type>
                    <methodname>authenticateUser</methodname>
                    <methodparam>
                        <modifier></modifier><type>std::string </type>
                            <parameter>sUser</parameter>
                    </methodparam>
                    <methodparam>
                        <modifier></modifier><type>std::string </type>
                            <parameter>sPassword</parameter>
                    </methodparam>
                </methodsynopsis>
            </term>
            <listitem>
                <para>
                    Given a user name;  <parameter>sUser</parameter> and a
                    password; <parameter>sPassword</parameter>, returns
                    <literal>true</literal> if that username and password
                    represent valid login credentials to the system,
                    <literal>false</literal> if not.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
                <methodsynopsis>
                    <modifier>static </modifier>
                    <type>int  </type>
                    <methodname>usleep</methodname>
                    <methodparam>
                        <modifier></modifier><type>useconds_t </type>
                            <parameter>usec</parameter>
                    </methodparam>
                </methodsynopsis>  
            </term>
            <listitem>
                <para>
                    Pauses the caller for <parameter>usec</parameter>
                    microseconds. <literal>0</literal> is returned if
                    the sleep was successful and for the full requested period.
                    <literal>-1</literal> is returned if not and <varname>errno</varname>
                    has an error code.  If <varname>errno</varname> is
                    <literal>EINTR</literal> 
                    the sleep was interrupted by a signal and the interval
                    was not complete.  Other values of <varname>errno</varname>represent errors.
                </para>
            </listitem>
        </varlistentry>        
        <varlistentry>
            <term>
                <methodsynopsis>
                    <modifier>static </modifier>
                    <type>int  </type>
                    <methodname>blockSignal</methodname>
                    <methodparam>
                        <modifier></modifier><type>int </type>
                            <parameter>sigNum</parameter>
                    </methodparam>
                </methodsynopsis>  
            </term>
            <listitem>
                <para>
                    Blocks the signal specified by <parameter>sigNum</parameter>.
                    If the signal can be blocked it will no longer be processed
                     by the calling process.  The method returns
                     <literal>0</literal> on success and <literal>-1</literal>
                     on failure.  If the call fails, <varname>errno</varname>
                     is a code that describes why the operation failed.
                </para>
            </listitem>
        </varlistentry>        
        <varlistentry>
            <term>
                <methodsynopsis>
                    <modifier>static </modifier>
                    <type>int  </type>
                    <methodname>checkStatus</methodname>
                    <methodparam>
                        <modifier></modifier><type>int status</type>
                            <parameter>, int checkStatus</parameter>
                    </methodparam>
                    <methodparam>
                        <modifier></modifier><type> std::string </type>
                            <parameter>msg</parameter>
                    </methodparam>
                </methodsynopsis>  
            </term>
            <listitem>
                <para>
                    Compares <parameter>status</parameter> with
                    <parameter>checkStatus</parameter> if not equal,
                    a <classname>std::runtime_error</classname> is thrown
                    with <parameter>msg</parameter> as the message string.
                    The function returns the value of <parameter>status</parameter>.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
                <methodsynopsis>
                    <modifier>static </modifier>
                    <type>int  </type>
                    <methodname>checkNegativeStatus</methodname>
                    <methodparam>
                        <modifier></modifier><type>int </type>
                            <parameter>returnCode</parameter>
                    </methodparam>
                </methodsynopsis>  
            </term>
            <listitem>
                <para>
                    If <parameter>returnCode</parameter> is negative,
                    the method throws a <classname>CErrnoException</classname>.
                    The exception string is the error string that corrersponds
                    to the <parameter>returnCode</parameter> as if
                    <parameter>returnCode</parameter> were a valid
                    <varname>errno</varname> error value.
                </para>
                <para>
                    On success, the value of <parameter>returnCode</parameter>
                    is returned.
                </para>
            </listitem>
        </varlistentry>
                
                
                    
     </variablelist>
  </refsect1>

</refentry>     

	 <refentry id="daqshm-manpage">
              <refentryinfo>
                <author>
                    <personname>
                        <firstname>Ron</firstname>
                        <surname>Fox</surname>
                    </personname>
                    <personblurb><para></para></personblurb>
                </author>
                <productname>NSCLDAQ</productname>
                <productnumber></productnumber>
              </refentryinfo>
            
       <refmeta>
          <refentrytitle>CDAQShm</refentrytitle>
          <manvolnum>3daq</manvolnum>
          <refmiscinfo class='empty'></refmiscinfo>
       </refmeta>
       <refnamediv>
          <refname>CDAQShm</refname>
          <refpurpose>class description</refpurpose>
       </refnamediv>
       
       <refsynopsisdiv>
        <synopsis>
#include &lt;daqshm.h&gt;
        
class <classname>CDAQShm</classname>
{        
    <methodsynopsis>
     <modifier>static</modifier><type>bool</type>
      <methodname>create</methodname>
      <methodparam><type>std::string</type><parameter>name</parameter></methodparam>
      <methodparam><type>size_t</type><parameter>size</parameter></methodparam>
      <methodparam><type>unsigned int</type><parameter>flags</parameter></methodparam>
    </methodsynopsis>
    <methodsynopsis>
     <modifier>static</modifier><type>void*</type>
     <methodname>attach</methodname>
     <methodparam><type>std::string</type><parameter>name</parameter></methodparam>
    </methodsynopsis>
    <methodsynopsis>
     <modifier>static</modifier><type>bool</type>
     <methodname>detach</methodname>
     <methodparam><type>void*</type><parameter>pSharedMemory</parameter></methodparam>
     <methodparam><type>std::string</type><parameter>name</parameter></methodparam>
     <methodparam><type>size_t</type><parameter>size</parameter></methodparam>
    </methodsynopsis>
    <methodsynopsis>
     <modifier>static</modifier><type>bool</type>
     <methodname>remove</methodname>
     <methodparam><type>std::string</type><parameter>name</parameter></methodparam>
    </methodsynopsis>
    <methodsynopsis>
      <modifier>static</modifier><type>ssize_t</type>
      <methodname>size</methodname>
       <methodparam>
         <type>std::string</type><parameter>name</parameter>
       </methodparam>
    </methodsynopsis>
    <methodsynopsis>
     <modifier>static</modifier><type>int</type>
     <methodname>lastError</methodname><void />
    </methodsynopsis>
    <methodsynopsis>
     <modifier>static</modifier><type>std::string</type>
     <methodname>errorMessage</methodname>
     <methodparam>
         <type>int</type><parameter>errorCode</parameter>
     </methodparam>
    </methodsynopsis>
    <methodsynopsis>
        <modifier></modifier>
        <type>int</type>
        <methodname>stat</methodname>
        <methodparam>
            <modifier></modifier><type>std::string</type>
                <parameter>name</parameter>
        </methodparam>
        <methodparam>
            <modifier></modifier><type>struct stat*</type>
                <parameter>pStat</parameter>
        </methodparam>
        <modifier></modifier>
    </methodsynopsis>  
   <fieldsynopsis><modifier>static const</modifier> <type>int</type> <varname>Success</varname></fieldsynopsis>
   <fieldsynopsis><modifier>static const</modifier> <type>int</type> <varname>Exists</varname></fieldsynopsis>
   <fieldsynopsis><modifier>static const</modifier> <type>int</type> <varname>NonExistent</varname></fieldsynopsis>
   <fieldsynopsis><modifier>static const</modifier> <type>int</type> <varname>NoAccess</varname></fieldsynopsis>
   <fieldsynopsis><modifier>static const</modifier> <type>int</type> <varname>NotAttached</varname></fieldsynopsis>
   <fieldsynopsis><modifier>static const</modifier> <type>int</type> <varname>CheckOSError</varname></fieldsynopsis>
   
   <fieldsynopsis><modifier>static const</modifier> <type>int</type> <varname>GroupRead</varname></fieldsynopsis>
   <fieldsynopsis><modifier>static const</modifier> <type>int</type> <varname>GroupWrite</varname></fieldsynopsis>
   <fieldsynopsis><modifier>static const</modifier> <type>int</type> <varname>OtherRead</varname></fieldsynopsis>
   <fieldsynopsis><modifier>static const</modifier> <type>int</type> <varname>OtherWrite</varname></fieldsynopsis>
};
            </synopsis>        
       </refsynopsisdiv>
       <refsect1>
          <title>DESCRIPTION</title>
          <para>
            Provides operating system independent access to underlying shared
            memory racilities.  The life cycle of a shared memory region
            is that it is created (which makes is persistent). Once created,
            processes can attach to the thread, and subsequently detach from
            the region.  At some point shared memory regions can be deleted.
          </para>
          <para>
            Shared memories are not gauranteed to survive across operating system
            reboots.
          </para>
       </refsect1>
       <refsect1>
          <title>
         METHODS
          </title>
          <variablelist>
            <varlistentry>
                <term>
                    <methodsynopsis>
                    <modifier>static</modifier><type>bool</type>
                     <methodname>create</methodname>
                     <methodparam><type>std::string</type><parameter>name</parameter></methodparam>
                     <methodparam><type>size_t</type><parameter>size</parameter></methodparam>
                     <methodparam><type>unsigned int</type><parameter>flags</parameter></methodparam>
                   </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Creates a new shared memory section.
                        <parameter>name</parameter> is the name of the
                        new region. <parameter>size</parameter> is the minimum
                        number of bytes of shared memory that will be created.
                        It is possible the shared memory will be larger than
                        <parameter>size</parameter> due to page alignment requirements.
                        <parameter>flags</parameter>is a bitwised or list of flags that
                        determine the access granted to other users.
                    </para>
                    <para>
                        See <link linkend='daqshm-varsrefsect' endterm='daqshm-varsrefsectt' />
                        for information about the bits in the flag parameter.
                    </para>
                    <para>
                        <literal>false</literal> is returned on success
                        and <literal>true</literal> on failure allowing for the
                        normal C style idiom of
                        <literal> if (CDAQShm::create(....)) { handle errors}</literal>
                    </para>
                </listitem>
            </varlistentry>
            
            <varlistentry>
                <term>
                    <methodsynopsis>
                     <modifier>static</modifier><type>void*</type>
                     <methodname>attach</methodname>
                     <methodparam><type>std::string</type><parameter>name</parameter></methodparam>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Attaches the process to an existing shared memory region.
                        The memory region is mapped into the process virtual
                        address space and a pointer to the first byte of that
                        virtual address space is returned.
                    </para>
                    <para>
                        <parameter>name</parameter> is the name of the shared memory
                        segment created via <methodname>create</methodname>.
                    </para>
                    <para>
                        On error, this method returns <literal>null</literal>.
                    </para>
                </listitem>
            </varlistentry>
            
            <varlistentry>
                <term>    
                    <methodsynopsis>
                     <modifier>static</modifier><type>bool</type>
                     <methodname>detach</methodname>
                     <methodparam><type>void*</type><parameter>pSharedMemory</parameter></methodparam>
                     <methodparam><type>std::string</type><parameter>name</parameter></methodparam>
                     <methodparam><type>size_t</type><parameter>size</parameter></methodparam>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Detaches from a shared memory region. <parameter>pSharedMemory</parameter>
                        is the pointer that was returned from <methodname>attach</methodname>
                        while <parameter>name</parameter> was the name of the shared
                        memory passed in to <methodname>attach</methodname>.
                        The size of the shared memory region is <parameter>size</parameter>
                    </para>
                    <para>
                        <literal>true</literal> is returned on error.
                    </para>
                </listitem>
            </varlistentry>
            
            
            <varlistentry>
                <term>
                    <methodsynopsis>
                     <modifier>static</modifier><type>bool</type>
                     <methodname>remove</methodname>
                     <methodparam><type>std::string</type><parameter>name</parameter></methodparam>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Marks the shared memory region <parameter>name</parameter>
                        for deletion by the operating system.  In most operating
                        systems, the underlying system call will not actually
                        delete the shared memory until all processes currently
                        attached either exit or detach.
                    </para>
                    <para>
                        The method returns <literal>true</literal> if
                        a failure is detected.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
              <term>
            <methodsynopsis>
             <modifier>static</modifier><type>ssize_t</type>
             <methodname>size</methodname>
              <methodparam>
                <type>std::string</type><parameter>name</parameter>
              </methodparam>
           </methodsynopsis>
                </term>
                <listitem>
                   <para>
                      Returns the number of bytes in a shared memory region.
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                     <modifier>static</modifier><type>int</type>
                     <methodname>lastError</methodname><void />
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns the status of the most recent call.
                        The set of values that might be returned is documented
                        below in
                        <link linkend='daqshm-varsrefsect' endterm='daqshm-varsrefsectt' />.
                    </para>
                </listitem>
            </varlistentry>
                        
           <varlistentry>
            <term>
                <methodsynopsis>
                 <modifier>static</modifier><type>std::string</type>
                 <methodname>errorMessage</methodname>
                 <methodparam>
                     <type>int</type><parameter>errorCode</parameter>
                 </methodparam>
                </methodsynopsis>
            </term>
            <listitem>
                <para>
                    Returns a textual error message that corresponds to the
                    <parameter>errorCode</parameter> gotten from a call
                    to <methodname>lastError</methodname>
                </para>
            </listitem>
           </varlistentry>
           <varlistentry>
               <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>int</type>
                        <methodname>stat</methodname>
                        <methodparam>
                            <modifier></modifier><type>std::string</type>
                                <parameter>name</parameter>
                        </methodparam>
                        <methodparam>
                            <modifier></modifier><type>struct stat*</type>
                                <parameter>pStat</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>  
               </term>
               <listitem>
                   <para>
                    Fills in the <parameter>pStat</parameter> file status
                    structure with the data appropriate to the
                    <parameter>name</parameter> shared memory section.
                    On error returns <literal>-1</literal>.
                   </para>
               </listitem>
           </varlistentry>
          </variablelist>
       </refsect1>
        <refsect1 id="daqshm-varsrefsect">
           <title id="daqshm-varsrefsectt">PUBLIC VARIABLES, TYPES and CONSTANTS</title>
           <para>
            This class exports two setsof constants. The first set has to do
            with reporting detailed status information (failure causes actuall).
            The second set describs the protections that are to be applied to a
            shared memory section at creation time.
           </para>
           <formalpara>
            <title>Status Codes:</title><para>
            <variablelist>
                <varlistentry>
                    <term>
                        <fieldsynopsis><modifier>static const</modifier> <type>int</type> <varname>Success</varname></fieldsynopsis>
                    </term>
                    <listitem>
                        <para>Successful completion of the operation.</para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                            <fieldsynopsis><modifier>static const</modifier> <type>int</type> <varname>Exists</varname></fieldsynopsis>
                    </term>
                    <listitem><para>Shared memory region already exists but is being <methodname>create</methodname>ed.</para></listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                            <fieldsynopsis><modifier>static const</modifier> <type>int</type> <varname>NonExistent</varname></fieldsynopsis>
                    </term>
                    <listitem><para>Shared memory region does not exist for <methodname>attach</methodname> or
                        <methodname>remove</methodname></para></listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                            <fieldsynopsis><modifier>static const</modifier> <type>int</type> <varname>NoAccess</varname></fieldsynopsis>
                    </term>
                    <listitem><para> The desired access was not allowe by the shared memory protections</para></listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                            <fieldsynopsis><modifier>static const</modifier> <type>int</type> <varname>NotAttached</varname></fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Shared memory section is not attached.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                            <fieldsynopsis><modifier>static const</modifier> <type>int</type> <varname>CheckOSError</varname></fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Check the underlying operating system's error code.
                        </para>
                    </listitem>
                </varlistentry>
                
                </variablelist>
            </para>
           </formalpara>
           <formalpara>
            <title>Permissions bits.</title>
            <para>
                These bits provide unix like permissions.
                <variablelist>
                    <varlistentry>
                        <term>
                            <fieldsynopsis><modifier>static const</modifier> <type>int</type> <varname>GroupRead</varname></fieldsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Allows members of the user's group to read the shared
                                memory section.  Such users can attach but no
                                write dereferencdes to the shared memory will work.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                            <fieldsynopsis><modifier>static const</modifier> <type>int</type> <varname>GroupWrite</varname></fieldsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Allows members of the user's group to write the shared
                                memory. Note that this does not imply read access
                                unless or-ed with <varname>GroupRead</varname>.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                            <fieldsynopsis><modifier>static const</modifier> <type>int</type> <varname>OtherRead</varname></fieldsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Allows people that are not in the user's group to
                                read the segment.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                            <fieldsynopsis><modifier>static const</modifier> <type>int</type> <varname>OtherWrite</varname></fieldsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Allows people that are not in the user's group
                                to write to the segment.
                            </para>
                        </listitem>
                    </varlistentry>
                </variablelist>
            </para>
           </formalpara>
           
            
        </refsect1>
     </refentry>
<refentry>
    <refmeta>
        <refentrytitle>io::CBufferedOutput</refentrytitle>
        <manvolnum>3daq</manvolnum>
    </refmeta>
    <refnamediv>
        <refname>io::CBufferedOutput</refname>
        <refpurpose>Simple binary buffered output class with flush.</refpurpose>
    </refnamediv>
    <refsynopsisdiv>
        <synopsis>
#include &lt;CBufferedOutput.h&gt;

class io::CBufferedOutput
{


public:
    CBufferedOutput(int fd, size_t nBytes);
    
    virtual void put(const void* pData, size_t nBytes);
    virtual void flush();
    void    sync();
    unsigned setTimeout(unsigned timeout);
    int getFd() const;


};

template &lt;class T&gt;
CBufferedOutput&amp; operator&lt;&lt;(CBufferedOutput&amp; b, T&amp; data);

        </synopsis>
        
    </refsynopsisdiv>
    <refsect1>
        <title>DESCRIPTION</title>
        <para>
            The <classname>io::CBufferedOutput</classname>
            class provides buffered output along with a streaming primitive
            for simple objects (that don't require deep copies to the
            output stream).  The class also features the capability of
            providing a timeout that ensures that slow writes will
            not necessarily require a full buffer to flush.
        </para>
    </refsect1>
    <refsect1>
        <title>METHODS</title>
        <variablelist>
            <varlistentry>
                <term>
                    <constructorsynopsis>
                        <methodname>io::CBufferedOutput</methodname>
                        <methodparam>
                            <type>int </type><parameter>fd</parameter>
                        </methodparam>
                        <methodparam>
                            <type>size_t </type><parameter>nBytes</parameter>
                        </methodparam>
                    </constructorsynopsis>
                </term>
                <listitem>
                    <para>
                        Wraps a buffered output object around a file descriptor
                        <parameter>fd</parameter>.
                        The file descriptor must have been opened by
                        e.g. <function>open</function>(2).
                        <parameter>nBytes</parameter> is the size of the output
                        buffer.  The output buffer is actualy written to the
                        file descriptor when a
                        <methodname>put</methodname> operation would overflow
                        the buffer.  
                    </para>
                    <para>
                        Additionally the buffer can be flushed if a  timeout
                        has been set and the time between consecutive puts
                        is longer than the timeout.  Finally the buffer can
                        be manually flushed as well.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual </modifier>
                        <type>void </type>
                        <methodname>put</methodname>
                        <methodparam>
                            <modifier>const </modifier>
                            <type>void* </type><parameter>pData</parameter>
                        </methodparam>
                        <methodparam>
                            <type>size_t </type><parameter>nBytes</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        "Writes" <parameter>nBytes</parameter> of data from
                        the data pointed to by <parameter>pData</parameter>.
                        In actual fact, the data are copied into the internal
                        buffer.  See the description of the constructor
                        for information about when the buffered data
                        are flushed to disk.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual </modifier>
                        <type>void </type>
                        <methodname>flush</methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Any buffered data are flushed to disk.  This is called
                        automatically at destruction time and as described
                        in the documentation for the constructor.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>void    </type>
                        <methodname>sync</methodname>
                        <void />
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Writing data to file via flush does not actually
                        ensure the data get written to disk.  The operating
                        system itself may also buffer the data.  This
                        method ensures that buffered data are not only
                        written to the file descriptor but that any
                        operating system buffers maintained for the file
                        are also written to disk.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>unsigned </type>
                        <methodname>setTimeout</methodname>
                        <methodparam>
                            <type>unsigned </type><parameter>timeout</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Sets the flush timeout in seconds.  If the time between
                        a put call and the last flush is greater than the
                        number of seconds in <parameter>timeout</parameter>,
                        the data will be flushed to disk regardless of the
                        fullness of the buffer.
                    </para>
                    <para>
                        The method returns the previous timeout value.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>int </type>
                        <methodname>getFd()</methodname>
                        <void />
                        <modifier>const</modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns the file descriptor used by the
                        object. Note that prior to writing to that
                        file descriptor, it's a really good idea to
                        <methodname>flush</methodname> it.
                        For the most part this is used for
                        testing and ordinary clients should not need to
                        call it.
                    </para>
                </listitem>
            </varlistentry>
        </variablelist>
    </refsect1>

</refentry>
<refentry>
    <refmeta>
        <refentrytitle>CRingBlockReader</refentrytitle>
        <manvolnum>3daq</manvolnum>
    </refmeta>
    <refnamediv>
        <refname>CRingBlockReader</refname>
        <refpurpose>ABC for reading blocks of ring items from a source.</refpurpose>
    </refnamediv>
    <refsynopsisdiv>
        <synopsis>
#include &lt;CRingBlockReader&gt;
            
class CRingBlockReader
{
  
  
public:
    typedef struct _DataDescriptor {
        std::uint32_t s_nBytes;
        std::uint32_t s_nItems;
        void*         s_pData;           
    } DataDescriptor, *pDataDescriptor;
public:
    CRingBlockReader();
    
    virtual DataDescriptor read(size_t nBytes);
protected:
    
    virtual ssize_t readBlock(void* pBuffer, size_t maxBytes) = 0;

};

        </synopsis>
    </refsynopsisdiv>
    <refsect1>
        <title>DESCRIPTION</title>
        <para>
            This is an abstract base class that uses a strategy pattern to
            read large blocks of data from some source and pass back to the user
            a description of the items in the block.  The items are only
            assumed to begin with a <type>uint32_t</type> size in bytes.
        </para>
        <para>
            Actual data transfer is done via the protected, pure virtual,
            method <methodname>readBlock</methodname>.  The base class
            properly handles items which span block boundaries transparently
            with respect concrete derive classes.
        </para>
        <para>
            Full customizability of the internals is also provided
            by making the public <methodname>read</methodname> method
            virtual as well.
        </para>
    </refsect1>
    <refsect1>
        <title>METHODS</title>
        <variablelist>
            <varlistentry>
                <term>
                    <constructorsynopsis>
                        <methodname>CRingBlockReader</methodname>
                        <void />
                    </constructorsynopsis>
                </term>
                <listitem>
                    <para>
                        Constructs the object.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual </modifier>
                        <type>DataDescriptor </type>
                        <methodname>read</methodname>
                        <methodparam>
                            <type>size_t</type><parameter>nBytes</parameter>
                        </methodparam>
                        <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Obtains at most <parameter>nBytes</parameter> of
                        data from the source.  The return value is a
                        <classname>CRingBlockReader</classname>::<structname>DataDescriptor</structname>.
                        See <literal>DataTypes</literal>.
                    </para>
                    <para>
                        It is important to know that the
                        <structfield>s_pData</structfield> field of the
                        returned structure points to data allocated dynamically
                        via <function>malloc</function>(3).  When the
                        caller is done using it that data must be released
                        via <function>free</function>(3).
                    </para>
                    <para>
                        It is an error if <parameter>nBytes</parameter>
                        cannot accommodate at least one complete item.  In that
                        case an <classname>std::logic_error</classname> is thrown.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>protected virtual </modifier>
                        <type>ssize_t </type>
                        <methodname>readBlock</methodname>
                        <methodparam>
                            <type>void* </type><parameter>pBuffer</parameter>
                        </methodparam>
                        <methodparam>
                            <type>size_t </type><parameter>maxBytes</parameter>
                        </methodparam>
                        <modifier>=0</modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Concrete sub-classes must implement this method.
                        The method must obtain at most
                        <parameter>maxBytes</parameter> from the data source
                        storing them in <parameter>pBuffer</parameter>.
                        The actual number of bytes returned is
                        the return value.  
                    </para>
                    <para>
                        A return value of 0 represents an end to the data source.
                        A return value less than zero indicates an error
                        whose reason is in the <varname>errno</varname>
                        variable.  The caller will transform errors like this
                        into throw <classname>std::system_error</classname>
                        exceptions.
                    </para>
                </listitem>
            </varlistentry>
        </variablelist>
    </refsect1>
    <refsect1>
        <title>DATA TYPES</title>
        <para>
            The class defines a nested struct:
            <classname>CRingBlockReader</classname>::<structname>DataDescriptor</structname>
            and an associated pointer type
            <classname>CRingBlockReader</classname>::<type>pDataDescriptor</type>
            which is a pointer to that struct.  The struct has the following
            fields:
        </para>
        <variablelist>
            <varlistentry>
                <term><type>std::uint32_t </type><structfield>s_nBytes</structfield></term>
                <listitem>
                    <para>
                        Number of bytes in this chunk of data.  This may be
                        less than the number of bytes requested of the read
                        but it will never be more than that.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><type>std::uint32_t </type><structfield>s_nItems</structfield></term>
                <listitem>
                    <para>
                        The number of items in the block read.  Each item is
                        assumed to have a leading <type>std::uint32_t</type>
                        that contains the size of the item in bytes.  Note that
                        this is also how NSCLDAQ ring items are formatted.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><type>void*</type> <structfield>s_pData</structfield></term>
                <listitem>
                    <para>
                        Pointer to the data.  The data pointed to is
                        allocated dynamically by <function>malloc</function>(3)
                        and must be deallocated by the client code when
                        appropriate via <function>free</function>(3).
                    </para>
                </listitem>
            </varlistentry>
        </variablelist>
    </refsect1>

</refentry>
<refentry>
    <refmeta>
        <refentrytitle>CRingFileBlockReader</refentrytitle>
        <manvolnum>3daq</manvolnum>
    </refmeta>
    <refnamediv>
        <refname>CRingFileBlockReader</refname>
        <refpurpose>CRingBlockreader that reads from file.</refpurpose>
    </refnamediv>
    <refsynopsisdiv>
        <synopsis>
#include &lt;CRingFileBlockReader.h&gt;
class CRingFileBlockReader : public CRingBlockReader
{
public:
  CRingFileBlockReader(const char* filename);
  CRingFileBlockReader(int fd);
 
};


        </synopsis>
    </refsynopsisdiv>
    <refsect1>
        <title>DESCRIPTION</title>
        <para>
            This is a concrete subclass of <classname>CRingBlockReader</classname>
            that reads data from a file.
        </para>
    </refsect1>
    <refsect1>
        <title>METHODS</title>
        <variablelist>
            <varlistentry>
                <term>
                    <constructorsynopsis>
                        <methodname>CRingFileBlockReader</methodname>
                        <methodparam>
                            <modifier>const </modifier>
                            <type>char* </type>
                            <parameter>filename</parameter>
                        </methodparam>
                    </constructorsynopsis>
                </term>
                <listitem>
                    <para>
                        Constructs the object using <parameter>filename</parameter>
                        a path to the file to be opened.  The file  must
                        be readable by the effective user id of the
                        runnning process.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <constructorsynopsis>
                        <methodname> CRingFileBlockReader</methodname>
                        <methodparam>
                            <type>int</type><parameter>int fd</parameter>
                        </methodparam>
                    </constructorsynopsis>
                </term>
                <listitem>
                    <para>
                        Constructs the reader on a file alread opened on the
                        file descriptor <parameter>fd</parameter>
                    </para>
                </listitem>
            </varlistentry>
        </variablelist>
    </refsect1>

</refentry>
<refentry>
   <refmeta>
      <refentrytitle>CElapsedTime</refentrytitle>
      <manvolnum>3daq</manvolnum>
   </refmeta>
   <refnamediv>
      <refname>CElapsedTime</refname>
      <refpurpose>Subsecond measurement of elapsed times.</refpurpose>
    </refnamediv>
    <refsynopsisdiv>
        <synopsis>
#include &lt;CElapsedTime&gt;
class CElapsedTime
{
public:
    CElapsedTime();
    void start();
    double measure() const;

};

        </synopsis>
    </refsynopsisdiv>
    <refsect1>
             <title>DESCRIPTION</title>
          <para>
            This class supports POSIX-.1-2001 conforming sub second interval
            measurement.
            Note that the actual resolution of this timing is dependent on the
            resolution of the underlying system clock used by
            <function>gettimeofday</function>(3).
          </para>
          <para>
            Constructing the object or invoking <methodname>start</methodname>
            on a constructed object sets a start time.  Subsequent calls to
            <methodname>measure</methodname> return the elapsed time since
            that start time in double precision seconds.
          </para>
    </refsect1>
</refentry>
<!-- /manpage -->